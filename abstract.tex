Correctly designing and implementing fault-tolerant distributed systems is notoriously hard. Protocols assume different fault-models to ensure safety and processes actions may be arbitrarily interleaved. In this thesis, we are interested in testing and verification methods for fault-tolerant distributed systems. Due to concurrency, verification and model checking are undecidable problems in general, even for finite state processes. There are several techniques to make this problem tractable, i.e., for a class of systems and properties, one can verify or find bugs. One such technique to make testing with model checking tractable is to compute a sequentialization, i.e., a sequential version of the protocol that is either equivalent or underapproximates the original distributed one. 

In this thesis, we introduce a rewriting procedure that transforms an asynchronous protocol into a sequential one. The sequentialization exploits the round structure of the protocol following the approach based on communication-closure. In general, the rewriting produces a sequential underapproximation of the asynchronous protocol. Moreover, for several common fault-models the rewriting produces an equivalent sequential protocol. To evaluate the benefits of the sequentialization, we compared testing the original asynchronous protocol with the sequential version we propose. We focus on systematic testing methods that use a model checker to explore the execution space and find bugs.

In this work, we propose a rewriting that guarantees equivalence in certain cases from an asynchronous to a sequential protocol. Asynchronous protocols are written in Distal, a domain specific language for fault-tolerant systems. Distal follows the event-driven paradigm, where the state of a process  tries to be updated upon the reception of a message. To compute an equivalent sequential protocol, we obtain as an intermediate step an equivalent synchronous protocol, i.e., Heard-of model. In the Heard-Of model, processes proceed in lock step executing a finite sequence of rounds in a loop. Rounds give an abstract notion of time. A round is composed of send and an update functions. All processes are in the same round during the execution. All messages are either received in the round they were sent for or are lost. We evaluated the proposed sequentialization on some consensus and replicated state machine protocols containing real bugs known by the community, e.g., Zookeeper Atomic Broadcast, Raft, Ben-Or, and looked for violations of safety. The most subtle bugs are not found in the asynchronous models, but they are in the sequential version.

The state of the art of communication closure does not permit using or sending messages from the past, i.e., timestamp messages with a previous phase or round. Some protocols perform such actions like recovery procedures that bring stale processes up-to-date with the last information, this produces a resend of past information. We define a reduction from an asynchronous to a synchronous that considers asynchronous executions where processes receive and send messages from the past. For verification, we explored verifying communication closure at the implementation level. We implemented Raft in Rust and use Prusti to verify communication closure.
