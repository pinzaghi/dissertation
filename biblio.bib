
@article{castro_practical_2001,
	title = {Practical {Byzantine} {Fault} {Tolerance}},
	abstract = {Our growing reliance on online services accessible on the Internet demands highly-available systems that provide correct service without interruptions. Byzantine faults such as software bugs, operator mistakes, and malicious attacks are the major cause of service interruptions. This thesis describes a new replication algorithm, BFT, that can be used to build highly-available systems that tolerate Byzantine faults. It shows, for the ﬁrst time, how to build Byzantine-fault-tolerant systems that can be used in practice to implement real services because they do not rely on unrealistic assumptions and they perform well. BFT works in asynchronous environments like the Internet, it incorporates mechanisms to defend against Byzantine-faulty clients, and it recovers replicas proactively. The recovery mechanism allows the algorithm to tolerate any number of faults over the lifetime of the ¡ system provided fewer than 1 3 of the replicas become faulty within a small window of vulnerability. The window may increase under a denial-of-service attack but the algorithm can detect and respond to such attacks and it can also detect when the state of a replica is corrupted by an attacker.},
	language = {en},
	author = {Castro, Miguel},
	month = jan,
	year = {2001},
	pages = {172},
	file = {Castro - Practical Byzantine Fault Tolerance.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/332QGQIQ/Castro - Practical Byzantine Fault Tolerance.pdf:application/pdf},
}

@article{liskov_viewstamped_2012,
	title = {Viewstamped {Replication} {Revisited}},
	abstract = {This paper presents an updated version of Viewstamped Replication, a replication technique that handles failures in which nodes crash. It describes how client requests are handled, how the group reorganizes when a replica fails, and how a failed replica is able to rejoin the group. The paper also describes a number of important optimizations and presents a protocol for handling reconﬁgurations that can change both the group membership and the number of failures the group is able to handle.},
	language = {en},
	author = {Liskov, Barbara and Cowling, James},
	month = jul,
	year = {2012},
	pages = {14},
	file = {Liskov and Cowling - Viewstamped Replication Revisited.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ASJGB6BC/Liskov and Cowling - Viewstamped Replication Revisited.pdf:application/pdf},
}

@inproceedings{sousa_byzantine_2012,
	address = {Sibiu},
	title = {From {Byzantine} {Consensus} to {BFT} {State} {Machine} {Replication}: {A} {Latency}-{Optimal} {Transformation}},
	isbn = {978-1-4673-0938-7 978-0-7695-4671-1},
	shorttitle = {From {Byzantine} {Consensus} to {BFT} {State} {Machine} {Replication}},
	url = {http://ieeexplore.ieee.org/document/6214759/},
	doi = {10.1109/EDCC.2012.32},
	abstract = {We present a new algorithm for state machine replication that is built around a leader-driven consensus primitive. This algorithm requires only two additional communication steps between replicas and clients if the consensus leader is correct and the system is synchronous, being thus the ﬁrst latency-optimal transformation from Byzantine consensus to BFT state machine replication. We also discuss how to make simple modiﬁcations to leader-driven consensus algorithms in order to make them compatible with our transformation.},
	language = {en},
	urldate = {2020-01-31},
	booktitle = {2012 {Ninth} {European} {Dependable} {Computing} {Conference}},
	publisher = {IEEE},
	author = {Sousa, J. and Bessani, A.},
	month = may,
	year = {2012},
	pages = {37--48},
	file = {Sousa et Bessani - 2012 - From Byzantine Consensus to BFT State Machine Repl.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ANHL6CT4/Sousa et Bessani - 2012 - From Byzantine Consensus to BFT State Machine Repl.pdf:application/pdf},
}

@inproceedings{chaouch-saad_reduction_2009,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Reduction} {Theorem} for the {Verification} of {Round}-{Based} {Distributed} {Algorithms}},
	isbn = {978-3-642-04420-5},
	doi = {10.1007/978-3-642-04420-5_10},
	abstract = {We consider the verification of algorithms expressed in the Heard-Of Model, a round-based computational model for fault-tolerant distributed computing. Rounds in this model are communication-closed, and we show that every execution recording individual events corresponds to a coarser-grained execution based on global rounds such that the local views of all processes are identical in the two executions. This result helps us to substantially mitigate state-space explosion and verify Consensus algorithms using standard model checking techniques.},
	language = {en},
	booktitle = {Reachability {Problems}},
	publisher = {Springer},
	author = {Chaouch-Saad, Mouna and Charron-Bost, Bernadette and Merz, Stephan},
	editor = {Bournez, Olivier and Potapov, Igor},
	year = {2009},
	keywords = {Consensus Algorithm, Consensus Problem, Local Property, Local Transition, Model Check},
	pages = {93--106},
	file = {Submitted Version:/home/pato/snap/zotero-snap/common/Zotero/storage/ZM3YLW3I/Chaouch-Saad et al. - 2009 - A Reduction Theorem for the Verification of Round-.pdf:application/pdf},
}

@inproceedings{jhala_predicate_2014,
	title = {Predicate {Abstraction} for {Program} {Verification}},
	abstract = {We present basic principles of algorithms for the verification of safety and termination of programs. The algorithms call procedures on logical formulas in order to construct an abstraction and to refine an abstraction. The two underlying concepts are predicate abstraction and counterexampleguided abstraction refinement. UC San Diego · University of Freiburg · Microsoft Research Cambridge · Technische Universität München},
	author = {Jhala, Ranjit and Podelski, Andreas and Rybalchenko, Andrey},
	year = {2014},
	keywords = {Algorithm, Approximation, Block code, Boolean, Cartesian closed category, Computation (action), Data-flow analysis, Dataflow, Decision problem, Fixed point (mathematics), Formal verification, Isolation (database systems), Microsoft Research, Predicate abstraction, Reachability, Refinement (computing), Verification of Theories},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/VQWIHIRM/Jhala et al. - 2014 - Chapter 1 Predicate Abstraction for Program Verifi.pdf:application/pdf},
}

@book{charron-bost_replication:_2010,
	address = {Berlin, Heidelberg},
	title = {Replication: {Theory} and {Practice}},
	isbn = {978-3-642-11293-5},
	shorttitle = {Replication},
	publisher = {Springer-Verlag},
	editor = {Charron-Bost, Bernadette and Pedone, Fernando and Schiper, André},
	year = {2010},
	file = {Goos et al. - Lecture Notes in Computer Science.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/2VJJW3WU/Goos et al. - Lecture Notes in Computer Science.pdf:application/pdf},
}

@incollection{defago_formal_2011,
	address = {Berlin, Heidelberg},
	title = {Formal {Verification} of {Consensus} {Algorithms} {Tolerating} {Malicious} {Faults}},
	volume = {6976},
	isbn = {978-3-642-24549-7 978-3-642-24550-3},
	url = {http://link.springer.com/10.1007/978-3-642-24550-3_11},
	abstract = {Consensus is the paradigmatic problem in fault-tolerant distributed computing: it requires network nodes that communicate by message passing to agree on common value even in the presence of (benign or malicious) faults. Several algorithms for solving Consensus exist, but few of them have been rigorously veriﬁed, much less so formally. The Heard-Of model proposes a simple, unifying framework for deﬁning distributed algorithms in the presence of communication faults. Algorithms proceed in communication-closed rounds, and assumptions on the faults tolerated by the algorithm are stated abstractly in the form of communication predicates. Extending previous work on the case of benign faults, our approach relies on the fact that properties such as Consensus can be veriﬁed over a coarse-grained, round-based representation of executions. We have encoded the Heard-Of model in the interactive proof assistant Isabelle/HOL and have used this encoding to formally verify three Consensus algorithms based on synchronous and asynchronous assumptions. Our proofs give some new insights into the correctness of the algorithms, in particular with respect to transient faults.},
	language = {en},
	urldate = {2019-11-19},
	booktitle = {Stabilization, {Safety}, and {Security} of {Distributed} {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Charron-Bost, Bernadette and Debrat, Henri and Merz, Stephan},
	editor = {Défago, Xavier and Petit, Franck and Villain, Vincent},
	year = {2011},
	doi = {10.1007/978-3-642-24550-3_11},
	pages = {120--134},
	file = {Charron-Bost et al. - 2011 - Formal Verification of Consensus Algorithms Tolera.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/YCJCI4SG/Charron-Bost et al. - 2011 - Formal Verification of Consensus Algorithms Tolera.pdf:application/pdf},
}

@book{manna_temporal_1995,
	address = {Place of publication not identified},
	title = {Temporal verification of reactive systems: safety.},
	isbn = {978-1-4612-4222-2},
	shorttitle = {Temporal verification of reactive systems},
	language = {en},
	publisher = {Springer},
	author = {Manna, Zohar and Pnueli, Amir},
	year = {1995},
	note = {OCLC: 968637592},
	file = {Manna - 2012 - Temporal verification of reactive systems safety..pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/8JS37SIT/Manna - 2012 - Temporal verification of reactive systems safety..pdf:application/pdf},
}

@article{fischer_impossibility_1985,
	title = {Impossibility of {Distributed} {Consensus} with {One} {Faulty} {Process}},
	abstract = {The consensusproblem involves an asynchronous system of processes,some of which may be unreliable. The problem is for the reliable processesto agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
	language = {en},
	author = {Fischer, J and Lynch, A and Paterson, S},
	year = {1985},
	pages = {9},
	file = {Fischer and Lynch - Impossibility of Distributed Consensuswith One Fau.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/67F5EZUR/Fischer and Lynch - Impossibility of Distributed Consensuswith One Fau.pdf:application/pdf},
}

@article{ohearn_primer_2012,
	title = {A {Primer} on {Separation} {Logic} (and {Automatic} {Program} {Veriﬁcation} and {Analysis})},
	abstract = {These are the notes to accompany a course at the Marktoberdorf PhD summer school in 2011. The course consists of an introduction to separation logic, with a slant towards its use in automatic program veriﬁcation and analysis.},
	language = {en},
	author = {O’Hearn, Peter W},
	year = {2012},
	pages = {33},
	file = {O’Hearn - A Primer on Separation Logic (and Automatic Progra.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/2STQJUP5/O’Hearn - A Primer on Separation Logic (and Automatic Progra.pdf:application/pdf},
}

@article{chandra_weakest_1996,
	title = {The {Weakest} {Failure} {Detector} for {Solving} {Consensus}},
	abstract = {We determine what information about failures is necessary and sufficient to solve Consensus in asynchronous distributed systems subject to crash failures. In Chandra and Toueg [1996], it is shown that \{\vphantom{\}}ᐃ, a failure detector that provides surprisingly little information about which processes have crashed, is sufficient to solve Consensus in asynchronous systems with a majority of correct processes. In this paper, we prove that to solve Consensus, any failure detector has to provide at least as much information as \{\vphantom{\}}ᐃ. Thus, \{\vphantom{\}}ᐃ is indeed the weakest failure detector for solving Consensus in asynchronous systems with a majority of correct processes.},
	language = {en},
	author = {Chandra, Tushar Deepak and Hadzilacos, Vassos},
	year = {1996},
	pages = {38},
	file = {Chandra and Hadzilacos - The Weakest Failure Detector for Solving Consensus.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/KE6NPCPY/Chandra and Hadzilacos - The Weakest Failure Detector for Solving Consensus.pdf:application/pdf},
}

@inproceedings{ben-or_another_1983,
	title = {Another {Advantage} of {Free} {Choice}: {Completely} {Asynchronous} {Agreement} {Protocols} ({Extended} {Abstract}).},
	shorttitle = {Another {Advantage} of {Free} {Choice}},
	doi = {10.1145/800221.806707},
	abstract = {Recently, Fischer, Lynch and Paterson [3] proved that no completely asynchronous consensus protocol can tolerate even a single unannounced process death. We exhibit here a probabilistic solution for this problem, which guarantees that as long as a majority of the processes continues to operate, a decision will be made (Theorem 1). Our solution is completely asynchronous and is rather strong: As in [4], it is guaranteed to work with probability 1 even against an adversary scheduler who knows all about the system.},
	author = {Ben-Or, Michael},
	month = jan,
	year = {1983},
	pages = {27--30},
	file = {ben1983another.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/L395MUKS/ben1983another.pdf:application/pdf},
}

@article{flanagan_predicate_2002,
	title = {Predicate {Abstraction} for {Software} {Veriﬁcation}},
	abstract = {Software veriﬁcation is an important and diﬃcult problem. Many static checking techniques for software require annotations from the programmer in the form of method speciﬁcations and loop invariants. This annotation overhead, particularly of loop invariants, is a signiﬁcant hurdle in the acceptance of static checking. We reduce the annotation burden by inferring loop invariants automatically.},
	language = {en},
	author = {Flanagan, Cormac and Qadeer, Shaz and Ave, Lytton},
	year = {2002},
	pages = {12},
	file = {Flanagan et al. - Predicate Abstraction for Software Veriﬁcation.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TAL93CWT/Flanagan et al. - Predicate Abstraction for Software Veriﬁcation.pdf:application/pdf},
}

@incollection{damm_structural_2007,
	address = {Berlin, Heidelberg},
	title = {Structural {Abstraction} of {Software} {Verification} {Conditions}},
	volume = {4590},
	isbn = {978-3-540-73367-6},
	url = {http://link.springer.com/10.1007/978-3-540-73368-3_41},
	abstract = {Precise software analysis and veriﬁcation require tracking the exact path along which a statement is executed (path-sensitivity), the different contexts from which a function is called (context-sensitivity), and the bit-accurate operations performed. Previously, veriﬁcation with such precision has been considered too inefﬁcient to scale to large software. In this paper, we present a novel approach to solving such veriﬁcation conditions, based on an automatic abstraction-checking-reﬁnement framework that exploits natural abstraction boundaries present in software. Experimental results show that our approach easily scales to over 200,000 lines of real C/C++ code.},
	language = {en},
	urldate = {2019-10-01},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer Berlin Heidelberg},
	author = {Babić, Domagoj and Hu, Alan J.},
	editor = {Damm, Werner and Hermanns, Holger},
	year = {2007},
	doi = {10.1007/978-3-540-73368-3_41},
	pages = {366--378},
	file = {Babić and Hu - 2007 - Structural Abstraction of Software Verification Co.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/RH9BQYC7/Babić and Hu - 2007 - Structural Abstraction of Software Verification Co.pdf:application/pdf},
}

@incollection{monien_time_1989,
	address = {Berlin/Heidelberg},
	title = {Time is not a healer},
	volume = {349},
	isbn = {978-3-540-50840-3},
	url = {http://www.springerlink.com/index/10.1007/BFb0028994},
	language = {en},
	urldate = {2019-09-24},
	booktitle = {{STACS} 89},
	publisher = {Springer-Verlag},
	author = {Santoro, Nicola and Widmayer, Peter},
	editor = {Monien, B. and Cori, R.},
	year = {1989},
	doi = {10.1007/BFb0028994},
	pages = {304--313},
	file = {Santoro and Widmayer - 1989 - Time is not a healer.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/L9UAMQNR/Santoro and Widmayer - 1989 - Time is not a healer.pdf:application/pdf},
}

@article{moreau_stability_2005,
	title = {Stability of multiagent systems with time-dependent communication links},
	volume = {50},
	issn = {0018-9286},
	url = {http://ieeexplore.ieee.org/document/1393134/},
	doi = {10.1109/TAC.2004.841888},
	abstract = {We study a simple but compelling model of network of agents interacting via time-dependent communication links. The model ﬁnds application in a variety of ﬁelds including synchronization, swarming and distributed decision making. In the model, each agent updates his current state based upon the current information received from neighboring agents. Necessary and/or sufﬁcient conditions for the convergence of the individual agents’ states to a common value are presented, thereby extending recent results reported in the literature. The stability analysis is based upon a blend of graph-theoretic and system-theoretic tools with the notion of convexity playing a central role. The analysis is integrated within a formal framework of set-valued Lyapunov theory, which may be of independent interest. Among others, it is observed that more communication does not necessarily lead to faster convergence and may eventually even lead to a loss of convergence, even for the simple models discussed in the present paper.},
	language = {en},
	number = {2},
	urldate = {2019-09-20},
	journal = {IEEE Transactions on Automatic Control},
	author = {Moreau, L.},
	month = feb,
	year = {2005},
	pages = {169--182},
	file = {Moreau - 2005 - Stability of multiagent systems with time-dependen.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/KJBEVLZI/Moreau - 2005 - Stability of multiagent systems with time-dependen.pdf:application/pdf},
}

@incollection{goos_abstract_2001,
	address = {Berlin, Heidelberg},
	title = {Abstract {Interpretation} {Based} {Formal} {Methods} and {Future} {Challenges}},
	volume = {2000},
	isbn = {978-3-540-41635-7 978-3-540-44577-7},
	url = {http://link.springer.com/10.1007/3-540-44577-3_10},
	abstract = {In order to contribute to the solution of the software reliabil­ ity problem, tools have been designed to analyze statically the run-time behavior of programs. Because the correctness problem is undecidable, some form of approximation is needed. The purpose of abstract interpre­ tation is to formalize this idea of approximation. We illustrate informally the application of abstraction to the semantics of programming languages as well as to static program analysis. The main point is that in order to reason or compute about a complex system, some information must be lost, that is the observation of executions must be either partial or at a high level of abstraction.},
	language = {en},
	urldate = {2019-09-15},
	booktitle = {Informatics},
	publisher = {Springer Berlin Heidelberg},
	author = {Cousot, Patrick},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Wilhelm, Reinhard},
	year = {2001},
	doi = {10.1007/3-540-44577-3_10},
	pages = {138--156},
	file = {Cousot - 2001 - Abstract Interpretation Based Formal Methods and F.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/C5I8VGWX/Cousot - 2001 - Abstract Interpretation Based Formal Methods and F.pdf:application/pdf},
}

@inproceedings{aguilera_consensus_2006,
	address = {Philadelphia, PA, USA},
	title = {Consensus with {Byzantine} {Failures} and {Little} {System} {Synchrony}},
	isbn = {978-0-7695-2607-2},
	url = {http://ieeexplore.ieee.org/document/1633504/},
	doi = {10.1109/DSN.2006.22},
	abstract = {We study consensus in a message-passing system where only some of the Ò¾ links exhibit some synchrony. This problem was previously studied for systems with process crashes; we now consider byzantine failures. We show that consensus can be solved in a system where there is at least one non-faulty process whose links are eventually timely; all other links can be arbitrarily slow. We also show that, in terms of problem solvability, such a system is strictly weaker than one where all links are eventually timely.},
	language = {en},
	urldate = {2019-08-22},
	booktitle = {International {Conference} on {Dependable} {Systems} and {Networks} ({DSN}'06)},
	publisher = {IEEE},
	author = {Aguilera, M.K. and Delporte-Gallet, C. and Fauconnier, H. and Toueg, S.},
	year = {2006},
	pages = {147--155},
	file = {Aguilera et al. - 2006 - Consensus with Byzantine Failures and Little Syste.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/GZYIS8YV/Aguilera et al. - 2006 - Consensus with Byzantine Failures and Little Syste.pdf:application/pdf},
}

@article{apt_proof_1980,
	title = {A {Proof} {System} for {Communicating} {Sequential} {Processes}},
	volume = {2},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/357103.357110},
	doi = {10.1145/357103.357110},
	abstract = {An axiomatic proof system is presented for proving partial correctness and absence of deadlock (and failure) of communicating sequential processes. The key (meta) rule introduces cooperation between proofs, a new concept needed to deal with proofs about synchronization by message passing. CSP's new convention for distributed termination of loops is dealt with. Applications of the method involve correctness proofs for two algorithms, one for distributed partitioning of sets, the other for distributed computation of the greatest common divisor of n numbers.},
	number = {3},
	urldate = {2019-08-06},
	journal = {ACM Trans. Program. Lang. Syst.},
	author = {Apt, Krzysztof R. and Francez, Nissim and de Roever, Willem P.},
	month = jul,
	year = {1980},
	pages = {359--385},
	file = {Full Text:/home/pato/snap/zotero-snap/common/Zotero/storage/LFLFFV2Y/Apt et al. - 1980 - A Proof System for Communicating Sequential Proces.pdf:application/pdf;Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/C2UETHAW/Apt et al. - 1980 - A Proof System for Communicating Sequential Proces.pdf:application/pdf},
}

@incollection{charron-bost_viewstamped_2010,
	address = {Berlin, Heidelberg},
	title = {From {Viewstamped} {Replication} to {Byzantine} {Fault} {Tolerance}},
	volume = {5959},
	isbn = {978-3-642-11293-5 978-3-642-11294-2},
	url = {http://link.springer.com/10.1007/978-3-642-11294-2_7},
	abstract = {The paper provides an historical perspective about two replication protocols, each of which was intended for practical deployment. The ﬁrst is Viewstamped Replication, which was developed in the 1980’s and allows a group of replicas to continue to provide service in spite of a certain number of crashes among them. The second is an extension of Viewstamped Replication that allows the group to survive Byzantine (arbitrary) failures. Both protocols allow users to execute general operations (thus they provide state machine replication); both were developed in the Programming Methodology group at MIT.},
	language = {en},
	urldate = {2019-08-01},
	booktitle = {Replication},
	publisher = {Springer Berlin Heidelberg},
	author = {Liskov, Barbara},
	editor = {Charron-Bost, Bernadette and Pedone, Fernando and Schiper, André},
	year = {2010},
	doi = {10.1007/978-3-642-11294-2_7},
	pages = {121--149},
	file = {Liskov - 2010 - From Viewstamped Replication to Byzantine Fault To.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/RLQZAK6M/Liskov - 2010 - From Viewstamped Replication to Byzantine Fault To.pdf:application/pdf},
}

@incollection{ahmed_velisarios:_2018,
	address = {Cham},
	title = {Velisarios: {Byzantine} {Fault}-{Tolerant} {Protocols} {Powered} by {Coq}},
	volume = {10801},
	isbn = {978-3-319-89883-4 978-3-319-89884-1},
	shorttitle = {Velisarios},
	url = {http://link.springer.com/10.1007/978-3-319-89884-1_22},
	abstract = {Our increasing dependence on complex and critical information infrastructures and the emerging threat of sophisticated attacks, ask for extended eﬀorts to ensure the correctness and security of these systems. Byzantine fault-tolerant state-machine replication (BFT-SMR) provides a way to harden such systems. It ensures that they maintain correctness and availability in an application-agnostic way, provided that the replication protocol is correct and at least n − f out of n replicas survive arbitrary faults. This paper presents Velisarios, a logic-of-events based framework implemented in Coq, which we developed to implement and reason about BFT-SMR protocols. As a case study, we present the ﬁrst machine-checked proof of a crucial safety property of an implementation of the area’s reference protocol: PBFT.},
	language = {en},
	urldate = {2019-06-24},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Rahli, Vincent and Vukotic, Ivana and Völp, Marcus and Esteves-Verissimo, Paulo},
	editor = {Ahmed, Amal},
	year = {2018},
	doi = {10.1007/978-3-319-89884-1_22},
	pages = {619--650},
	file = {Rahli et al. - 2018 - Velisarios Byzantine Fault-Tolerant Protocols Pow.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TSGMM7Y7/Rahli et al. - 2018 - Velisarios Byzantine Fault-Tolerant Protocols Pow.pdf:application/pdf},
}

@article{castro_practical_2002,
	title = {Practical byzantine fault tolerance and proactive recovery},
	volume = {20},
	issn = {07342071},
	url = {http://portal.acm.org/citation.cfm?doid=571637.571640},
	doi = {10.1145/571637.571640},
	language = {en},
	number = {4},
	urldate = {2019-05-22},
	journal = {ACM Transactions on Computer Systems},
	author = {Castro, Miguel and Liskov, Barbara},
	month = nov,
	year = {2002},
	pages = {398--461},
	file = {Castro and Liskov - 2002 - Practical byzantine fault tolerance and proactive .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/MPGQGZEF/Castro and Liskov - 2002 - Practical byzantine fault tolerance and proactive .pdf:application/pdf},
}

@article{hoare_axiomatic_1969,
	title = {An {Axiomatic} {Basis} for {Computer} {Programming}},
	volume = {12},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/363235.363259},
	doi = {10.1145/363235.363259},
	abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
	number = {10},
	urldate = {2019-05-22},
	journal = {Commun. ACM},
	author = {Hoare, C. A. R.},
	month = oct,
	year = {1969},
	keywords = {axiomatic method, formal language definition, machine-independent programming, program documentation, programming language design, theory of programming' proofs of programs},
	pages = {576--580},
	file = {Hoare69.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/U4X8NQ5H/Hoare69.pdf:application/pdf},
}

@inproceedings{reynolds_separation_2002,
	address = {Washington, DC, USA},
	series = {{LICS} '02},
	title = {Separation {Logic}: {A} {Logic} for {Shared} {Mutable} {Data} {Structures}},
	isbn = {978-0-7695-1483-3},
	shorttitle = {Separation {Logic}},
	url = {http://dl.acm.org/citation.cfm?id=645683.664578},
	abstract = {In joint work with Peter O'Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperativeprograms that use shared mutable data structure.The simple imperative programming language is extended with commands (not expressions) for accessing and modifying shared structures, and for explicit allocation and deallocation of storage. Assertions are extended by introducing a "separating conjunction" that asserts that its sub-formulas hold for disjoint parts of the heap, and a closely related "separating implication". Coupled with the inductive definition of predicates on abstract data structures, this extension permits the concise and flexible description of structures with controlled sharing.In this paper, we will survey the current development of this program logic, including extensions that permit unrestricted address arithmetic, dynamically allocated arrays, and recursive procedures. We will also discuss promising future directions.},
	urldate = {2019-05-21},
	booktitle = {Proceedings of the 17th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE Computer Society},
	author = {Reynolds, John C.},
	year = {2002},
	pages = {55--74},
	file = {Reynolds - 2002 - Separation logic a logic for shared mutable data .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/2UUUR3WE/Reynolds - 2002 - Separation logic a logic for shared mutable data .pdf:application/pdf},
}

@article{konnov_bymc:_2018,
	title = {{ByMC}: {Byzantine} {Model} {Checker}},
	shorttitle = {{ByMC}},
	url = {https://hal.inria.fr/hal-01909653},
	abstract = {In recent work [12,10], we have introduced a technique for automatic verification of threshold-guarded distributed algorithms that have the following features: (1) up to t of processes may crash or behave Byzantine; (2) the correct processes count messages and progress when they receive sufficiently many messages, e.g., at least t + 1; (3) the number n of processes in the system is a parameter, as well as t; (4) and the parameters are restricted by a resilience condition, e.g., n {\textgreater} 3t. In this paper, we present Byzantine Model Checker that implements the above-mentioned technique. It takes two kinds of inputs, namely, (i) threshold automata (the framework of our verification techniques) or (ii) Parametric Promela (which is similar to the way in which the distributed algorithms were described in the literature). We introduce a parallel extension of the tool, which exploits the parallelism enabled by our technique on an MPI cluster. We compare performance of the original technique and of the extensions by verifying 10 benchmarks that model fault-tolerant distributed algorithms from the literature. For each benchmark algorithm we check two encodings: a manual encoding in threshold automata vs. a Promela encoding.},
	language = {en},
	urldate = {2019-05-12},
	author = {Konnov, Igor and Widder, Josef},
	month = oct,
	year = {2018},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/4QBN6VVG/Konnov and Widder - 2018 - ByMC Byzantine Model Checker.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/4S69C72Y/hal-01909653.html:text/html},
}

@inproceedings{gafni_round-by-round_1998,
	title = {Round-by-{Round} {Fault} {Detectors}: {Unifying} {Synchrony} and {Asynchrony} ({Extended} {Abstract}).},
	shorttitle = {Round-by-{Round} {Fault} {Detectors}},
	doi = {10.1145/277697.277724},
	abstract = {This paper presents a new family of models of distributed-computation which combines features from synchronous, asynchronous, and failure-detector-augmented systems. Like synchronous systems, computation in this family of models evolves in rounds, and communication missed at a round is lost. Unlike synchronous systems, information that is missed at a round does not necessarily imply a real process failure. The features of a specific model is captured in an abstract module called the round-by-round fault detector. The abstraction of system features into such a module facilitates the comparison of different systems, by contrasting their associated fault detectors. We show that this family of models unifies the study of synchrony, asynchrony, message-passing and shared memory. We further show that this approach leads to the development of shorter and simpler proofs of important results such as a lower bound on the number of rounds to achieve k-set agreement in a synchronous system. We believe that studying distributed systems through the proposed unifying framework will lead to new results and insights.},
	author = {Gafni, Eli},
	month = jan,
	year = {1998},
	pages = {143--152},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/MRLXAYWR/Gafni - 1998 - Round-by-Round Fault Detectors Unifying Synchrony.pdf:application/pdf},
}

@inproceedings{tsuchiya_model_2007,
	address = {Beijing},
	title = {Model {Checking} of {Consensus} {Algorithms}},
	isbn = {978-0-7695-2995-0},
	url = {https://ieeexplore.ieee.org/document/4365691/},
	doi = {10.1109/SRDS.2007.20},
	abstract = {We show for the ﬁrst time that standard model checking allows one to completely verify asynchronous algorithms for solving consensus, a fundamental problem in fault-tolerant distributed computing. Model checking is a powerful veriﬁcation methodology based on state exploration. However it has rarely been applied to consensus algorithms, because these algorithms induce huge, often inﬁnite state spaces. Here we focus on consensus algorithms based on the Heard-Of model, a new computation model for distributed computing. By making use of the high abstraction level provided by this computation model and by devising a ﬁnite representation of unbounded timestamps, we develop a methodology for verifying consensus algorithms in every possible state by model checking.},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {2007 26th {IEEE} {International} {Symposium} on {Reliable} {Distributed} {Systems} ({SRDS} 2007)},
	publisher = {IEEE},
	author = {Tsuchiya, Tatsuhiro and Schiper, Andre},
	month = oct,
	year = {2007},
	pages = {137--148},
	file = {Tsuchiya and Schiper - 2007 - Model Checking of Consensus Algorit.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/GG2WV2BP/Tsuchiya and Schiper - 2007 - Model Checking of Consensus Algorit.pdf:application/pdf},
}

@article{damian_communication-closed_2019,
	title = {Communication-closed asynchronous protocols},
	abstract = {Fault-tolerant distributed systems are implemented over asynchronous networks, so that they use algorithms for asynchronous models with faults. Due to asynchronous communication and the occurrence of faults (e.g., process crashes or the network dropping messages) the implementations are hard to understand and analyze. In contrast, synchronous computation models simplify design and reasoning. In this paper, we bridge the gap between these two worlds. For a class of asynchronous protocols, we introduce a procedure that, given an asynchronous protocol, soundly computes its round-based synchronous counterpart. This class is deﬁned by properties of the sequential code.},
	language = {en},
	author = {Damian, Andrei and Drăgoi, Cezara and Militaru, Alexandru and Widder, Josef},
	year = {2019},
	pages = {28},
	file = {CAV2019 (short).pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/AX8K7ZWD/CAV2019 (short).pdf:application/pdf;INRIA HAL (detailed).pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VH2IHTUV/INRIA HAL (detailed).pdf:application/pdf;main.pdf:/home/inzaghi/workspace/writings/commclosed2019/main.pdf:application/pdf;Proceedings.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/MQT7YTPP/Proceedings.pdf:application/pdf},
}

@article{padon_ivy:_2016,
	title = {Ivy: {Safety} {Veriﬁcation} by {Interactive} {Generalization}},
	abstract = {Despite several decades of research, the problem of formal veriﬁcation of inﬁnite-state systems has resisted effective automation. We describe a system — Ivy — for interactively verifying safety of inﬁnite-state systems. Ivy’s key principle is that whenever veriﬁcation fails, Ivy graphically displays a concrete counterexample to induction. The user then interactively guides generalization from this counterexample. This process continues until an inductive invariant is found. Ivy searches for universally quantiﬁed invariants, and uses a restricted modeling language. This ensures that all veriﬁcation conditions can be checked algorithmically. All user interactions are performed using graphical models, easing the user’s task. We describe our initial experience with verifying several distributed protocols.},
	language = {en},
	author = {Padon, Oded and McMillan, Kenneth L and Panda, Aurojit and Sagiv, Mooly and Shoham, Sharon},
	year = {2016},
	pages = {17},
	file = {Padon et al. - Ivy Safety Veriﬁcation by Interactive Generalizat.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/IKND5R62/Padon et al. - Ivy Safety Veriﬁcation by Interactive Generalizat.pdf:application/pdf},
}

@article{castro_practical_1999,
	title = {Practical {Byzantine} {Fault} {Tolerance}},
	abstract = {This paper describes a new replication algorithm that is able to tolerate Byzantine faults. We believe that Byzantinefault-tolerant algorithms will be increasingly important in the future because malicious attacks and software errors are increasingly common and can cause faulty nodes to exhibit arbitrary behavior. Whereas previous algorithms assumed a synchronous system or were too slow to be used in practice, the algorithm described in this paper is practical: it works in asynchronous environments like the Internet and incorporates several important optimizations that improve the response time of previous algorithms by more than an order of magnitude. We implemented a Byzantine-fault-tolerant NFS service using our algorithm and measured its performance. The results show that our service is only 3\% slower than a standard unreplicated NFS.},
	language = {en},
	author = {Castro, Miguel and Liskov, Barbara},
	year = {1999},
	pages = {14},
	file = {Castro and Liskov - Practical Byzantine Fault Tolerance.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/QAU4S6LN/Castro and Liskov - Practical Byzantine Fault Tolerance.pdf:application/pdf;Presentation.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/7V6WI657/Castro and Liskov - 1999 - Practical Byzantine Fault Tolerance.pdf:application/pdf},
}

@article{dragoi_psync:_2016,
	title = {{PSYNC}: {A} partially synchronous language for fault-tolerant distributed algorithms},
	abstract = {Fault-tolerant distributed algorithms play an important role in many critical/high-availability applications. These algorithms are notoriously difﬁcult to implement correctly, due to asynchronous communication and the occurrence of faults, such as the network dropping messages or computers crashing.},
	language = {en},
	author = {Drăgoi, Cezara and Henzinger, Thomas A and Zufferey, Damien},
	year = {2016},
	pages = {16},
	file = {Dra et al. - PSYNC A partially synchronous language for fault-.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/6WEWKYBR/Dra et al. - PSYNC A partially synchronous language for fault-.pdf:application/pdf},
}

@article{henzinger_synchronizing_2017,
	title = {Synchronizing the {Asynchronous}},
	language = {en},
	author = {Henzinger, Thomas A and Kragl, Bernhard and Qadeer, Shaz and Research, Microso},
	year = {2017},
	pages = {28},
	file = {Henzinger et al. - Synchronizing the Asynchronous.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/MZ8CACYR/Henzinger et al. - Synchronizing the Asynchronous.pdf:application/pdf},
}

@article{wilcox_verdi:_2015,
	title = {Verdi: {A} {Framework} for {Implementing} and {Formally} {Verifying} {Distributed} {Systems}},
	abstract = {Distributed systems are difﬁcult to implement correctly because they must handle both concurrency and failures: machines may crash at arbitrary points and networks may reorder, drop, or duplicate packets. Further, their behavior is often too complex to permit exhaustive testing. Bugs in these systems have led to the loss of critical data and unacceptable service outages.},
	language = {en},
	author = {Wilcox, James R and Woos, Doug and Panchekha, Pavel and Tatlock, Zachary and Wang, Xi and Ernst, Michael D and Anderson, Thomas},
	year = {2015},
	pages = {12},
	file = {Wilcox et al. - Verdi A Framework for Implementing and Formally V.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/C2EYSZLW/Wilcox et al. - Verdi A Framework for Implementing and Formally V.pdf:application/pdf},
}

@article{debrat_verifying_2018,
	title = {Verifying {Fault}-{Tolerant} {Distributed} {Algorithms} {In} {The} {Heard}-{Of} {Model}},
	language = {en},
	author = {Debrat, Henri and Merz, Stephan and de Lorraine, Universite},
	year = {2018},
	pages = {166},
	file = {Debrat et al. - Verifying Fault-Tolerant Distributed Algorithms In.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/FCY9LTAL/Debrat et al. - Verifying Fault-Tolerant Distributed Algorithms In.pdf:application/pdf},
}

@article{kotla_zyzzyva:_2007,
	title = {Zyzzyva: {Speculative} {Byzantine} {Fault} {Tolerance}},
	abstract = {We present Zyzzyva, a protocol that uses speculation to reduce the cost and simplify the design of Byzantine fault tolerant state machine replication. In Zyzzyva, replicas respond to a client’s request without ﬁrst running an expensive three-phase commit protocol to reach agreement on the order in which the request must be processed. Instead, they optimistically adopt the order proposed by the primary and respond immediately to the client. Replicas can thus become temporarily inconsistent with one another, but clients detect inconsistencies, help correct replicas converge on a single total ordering of requests, and only rely on responses that are consistent with this total order. This approach allows Zyzzyva to reduce replication overheads to near their theoretical minima.},
	language = {en},
	author = {Kotla, Ramakrishna and Alvisi, Lorenzo and Dahlin, Mike and Clement, Allen and Wong, Edmund},
	year = {2007},
	pages = {14},
	file = {Kotla et al. - Zyzzyva Speculative Byzantine Fault Tolerance.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/6AQ5VVHK/Kotla et al. - Zyzzyva Speculative Byzantine Fault Tolerance.pdf:application/pdf},
}

@article{lamport_pretending_1989,
	title = {Pretending {Atomicity}},
	url = {https://www.microsoft.com/en-us/research/publication/pretending-atomicity/},
	abstract = {Reasoning about concurrent systems is simpler if they have fewer separate atomic actions. To simplify reasoning about systems, we’d like to be able to combine multiple small atomic actions into a single large one. This process is called reduction. This paper contains a reduction theorem for multiprocess programs. It was accepted for publication, subject to …},
	language = {en-US},
	urldate = {2019-05-05},
	journal = {SRC Research Report 44},
	author = {Lamport, Leslie and Schneider, Fred B.},
	month = may,
	year = {1989},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/HQCI56M8/Lamport and Schneider - 2016 - Pretending Atomicity.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/XVK9QLDN/pretending-atomicity.html:text/html},
}

@article{lamport_part-time_1998,
	title = {The part-time parliament},
	volume = {16},
	issn = {07342071},
	url = {http://portal.acm.org/citation.cfm?doid=279227.279229},
	doi = {10.1145/279227.279229},
	language = {en},
	number = {2},
	urldate = {2019-05-05},
	journal = {ACM Transactions on Computer Systems},
	author = {Lamport, Leslie},
	month = may,
	year = {1998},
	pages = {133--169},
	file = {Lamport - 1998 - The part-time parliament.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/I9NNA4KW/Lamport - 1998 - The part-time parliament.pdf:application/pdf},
}

@article{sergey_programming_2017,
	title = {Programming and proving with distributed protocols},
	volume = {2},
	issn = {24751421},
	url = {http://dl.acm.org/citation.cfm?doid=3177123.3158116},
	doi = {10.1145/3158116},
	language = {en},
	number = {POPL},
	urldate = {2019-05-05},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Sergey, Ilya and Wilcox, James R. and Tatlock, Zachary},
	month = dec,
	year = {2017},
	pages = {1--30},
	file = {Sergey et al. - 2017 - Programming and proving with distributed protocols.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TFB74Q7M/Sergey et al. - 2017 - Programming and proving with distributed protocols.pdf:application/pdf},
}

@article{martin_fast_2006,
	title = {Fast {Byzantine} {Consensus}.},
	volume = {3},
	doi = {10.1109/DSN.2005.48},
	abstract = {We present the first consensus protocol that reaches asynchronous Byzantine consensus in two communication steps in the common case. We prove that our protocol is optimal in terms of both number of communication step, and number of processes for 2-step consensus. The protocol can be used to build a replicated state machine that requires only three communication steps per request in the common case.},
	journal = {IEEE Trans. Dependable Sec. Comput.},
	author = {Martin, Jean-Philippe and Alvisi, Lorenzo},
	month = jan,
	year = {2006},
	pages = {202--215},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/LEV5BET9/Martin and Alvisi - 2006 - Fast Byzantine Consensus..pdf:application/pdf},
}

@incollection{majumdar_cutoff_2017,
	address = {Cham},
	title = {Cutoff {Bounds} for {Consensus} {Algorithms}},
	volume = {10427},
	isbn = {978-3-319-63389-3 978-3-319-63390-9},
	url = {http://link.springer.com/10.1007/978-3-319-63390-9_12},
	abstract = {Consensus algorithms are fundamental building blocks for fault-tolerant distributed systems and their correctness is critical. However, there are currently no fully-automated methods for their veriﬁcation. The main diﬃculty is that the algorithms are parameterized: they should work for any given number of processes. We provide an expressive language for consensus algorithms targeting the benign asynchronous setting. For this language, we give algorithm-dependent cutoﬀ bounds. A cutoﬀ bound B reduces the parameterized veriﬁcation of consensus to a setting with B processes. For the algorithms in our case studies, we obtain bounds of 5 or 7, enabling us to model check them eﬃciently. This is the ﬁrst cutoﬀ result for fault-tolerant distributed systems.},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer International Publishing},
	author = {Marić, Ognjen and Sprenger, Christoph and Basin, David},
	editor = {Majumdar, Rupak and Kunčak, Viktor},
	year = {2017},
	doi = {10.1007/978-3-319-63390-9_12},
	pages = {217--237},
	file = {Marić et al. - 2017 - Cutoff Bounds for Consensus Algorithms.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/LYAK2TNR/Marić et al. - 2017 - Cutoff Bounds for Consensus Algorithms.pdf:application/pdf},
}

@inproceedings{lynch_hierarchical_1987,
	address = {Vancouver, British Columbia, Canada},
	title = {Hierarchical correctness proofs for distributed algorithms},
	url = {http://portal.acm.org/citation.cfm?doid=41840.41852},
	doi = {10.1145/41840.41852},
	abstract = {We introduce the input-output automaton, a simple but powerful model of computation in asynchronous distributed networks. With this model we are able to construct modular, hierarchical correctness proofs for distributed algorithms. We de ne this model, and give an interesting example of how it can be used to construct such proofs.},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {Proceedings of the sixth annual {ACM} {Symposium} on {Principles} of distributed computing  - {PODC} '87},
	publisher = {ACM Press},
	author = {Lynch, Nancy A. and Tuttle, Mark R.},
	year = {1987},
	pages = {137--151},
	file = {Lynch and Tuttle - 1987 - Hierarchical correctness proofs for distributed al.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VPIZZFSZ/Lynch and Tuttle - 1987 - Hierarchical correctness proofs for distributed al.pdf:application/pdf},
}

@book{lynch_distributed_1997,
	address = {San Francisco, Calif},
	series = {The {Morgan} {Kaufmann} series in data management systems},
	title = {Distributed algorithms},
	isbn = {978-1-55860-348-6},
	publisher = {Morgan Kaufmann},
	author = {Lynch, Nancy A.},
	year = {1997},
	keywords = {Computer algorithms, Distributed processing, Electronic data processing},
	file = {Lynch - 1997 - Distributed algorithms.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/K2UN94ZI/Lynch - 1997 - Distributed algorithms.pdf:application/pdf},
}

@incollection{peleg_byzantizing_2011,
	address = {Berlin, Heidelberg},
	title = {Byzantizing {Paxos} by {Refinement}},
	volume = {6950},
	isbn = {978-3-642-24099-7 978-3-642-24100-0},
	url = {http://link.springer.com/10.1007/978-3-642-24100-0_22},
	abstract = {We derive a 3f + 1 process Byzantine Paxos consensus algorithm by Byzantizing a variant of the ordinary Paxos algorithm—that is, by having 2f + 1 nonfaulty processes emulate the ordinary Paxos algorithm despite the presence of f malicious processes. We have written a formal, machine-checked proof that the Byzantized algorithm implements the ordinary Paxos consensus algorithm under a suitable reﬁnement mapping.},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {Distributed {Computing}},
	publisher = {Springer Berlin Heidelberg},
	author = {Lamport, Leslie},
	editor = {Peleg, David},
	year = {2011},
	doi = {10.1007/978-3-642-24100-0_22},
	pages = {211--224},
	file = {Lamport - 2011 - Byzantizing Paxos by Refinement.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/5LCXCKFU/Lamport - 2011 - Byzantizing Paxos by Refinement.pdf:application/pdf},
}

@article{hoare_communicating_1978,
	title = {Communicating sequential processes},
	volume = {21},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=359576.359585},
	doi = {10.1145/359576.359585},
	abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar programming exercises.},
	language = {en},
	number = {8},
	urldate = {2019-05-05},
	journal = {Communications of the ACM},
	author = {Hoare, C. A. R.},
	month = aug,
	year = {1978},
	pages = {666--677},
	file = {Hoare - 1978 - Communicating sequential processes.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/WU7MFCZV/Hoare - 1978 - Communicating sequential processes.pdf:application/pdf},
}

@article{hawblitzel_ironfleet:_2017,
	title = {{IronFleet}: proving safety and liveness of practical distributed systems},
	volume = {60},
	issn = {00010782},
	shorttitle = {{IronFleet}},
	url = {http://dl.acm.org/citation.cfm?doid=3116227.3068608},
	doi = {10.1145/3068608},
	abstract = {In more detail, we formally specify, in Dafny, a distributed system state machine. This state machine consists of N host state machines and a set of network packets. In each step of the distributed system state machine, one host’s state machine takes a step, allowing it to atomically read messages from the network, update its state, and send messages to the network; our reduction argument relaxes this atomicity assumption (see full paper).},
	language = {en},
	number = {7},
	urldate = {2019-05-05},
	journal = {Communications of the ACM},
	author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jacob R. and Parno, Bryan and Roberts, Michael L. and Setty, Srinath and Zill, Brian},
	month = jun,
	year = {2017},
	pages = {83--92},
	file = {Hawblitzel et al. - 2017 - IronFleet proving safety and liveness of practica.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/68LTYCTH/Hawblitzel et al. - 2017 - IronFleet proving safety and liveness of practica.pdf:application/pdf},
}

@techreport{garay_bitcoin_2014,
	title = {The {Bitcoin} {Backbone} {Protocol}: {Analysis} and {Applications}},
	shorttitle = {The {Bitcoin} {Backbone} {Protocol}},
	url = {http://eprint.iacr.org/2014/765},
	abstract = {Bitcoin is the first and most popular decentralized cryptocurrency to date. In this work, we extract and analyze the core of the Bitcoin protocol, which we term the Bitcoin backbone, and prove two of its fundamental properties which we call common prefix and chain quality in the static setting where the number of players remains fixed. Our proofs hinge on appropriate and novel assumptions on the hashing power of the adversary relative to network synchronicity; we show our results to be tight under high synchronization. Next, we propose and analyze applications that can be built on top of the backbone protocol, specifically focusing on Byzantine agreement (BA) and on the notion of a public transaction ledger. Regarding BA, we observe that Nakamoto's suggestion falls short of solving it, and present a simple alternative which works assuming that the adversary's hashing power is bounded by 1/3. The public transaction ledger captures the essence of Bitcoin's operation as a cryptocurrency, in the sense that it guarantees the liveness and persistence of committed transactions. Based on this notion we describe and analyze the Bitcoin system as well as a more elaborate BA protocol, proving them secure assuming high network synchronicity and that the adversary's hashing power is strictly less than 1/2, while the adversarial bound needed for security decreases as the network desynchronizes. Finally, we show that our analysis of the Bitcoin backbone protocol for synchronous networks extends with relative ease to the recently considered partially synchronous model, where there is an upper bound in the delay of messages that is unknown to the honest parties.},
	number = {765},
	urldate = {2019-05-05},
	author = {Garay, Juan and Kiayias, Aggelos and Leonardos, Nikos},
	year = {2014},
	keywords = {applications},
	file = {ePrint IACR Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/6DB4B4MI/Garay et al. - 2014 - The Bitcoin Backbone Protocol Analysis and Applic.pdf:application/pdf;ePrint IACR Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/8IHAKJ9A/765.html:text/html},
}

@article{elrad_decomposition_1982,
	title = {Decomposition of distributed programs into communication-closed layers},
	volume = {2},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0167642383900138},
	doi = {10.1016/0167-6423(83)90013-8},
	abstract = {The safe decomposition of a distributed program into communication closed layers is suggested as a superstructure of its decomposition into a collection of communicating processes. This decomposition may simplify the analysis of a distributed program, as is exemplified by examples of program verification. A programming language construct to enforce safety of a decomposition is introduced. The application to systematic construction of distributed programs is also shown.},
	language = {en},
	number = {3},
	urldate = {2019-05-05},
	journal = {Science of Computer Programming},
	author = {Elrad, Tzilla and Francez, Nissim},
	month = dec,
	year = {1982},
	pages = {155--173},
	file = {Elrad and Francez - 1982 - Decomposition of distributed programs into communi.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/THPLSU9L/Elrad and Francez - 1982 - Decomposition of distributed programs into communi.pdf:application/pdf},
}

@article{dwork_consensus_1988,
	title = {Consensus in the presence of partial synchrony},
	volume = {35},
	issn = {00045411},
	url = {http://portal.acm.org/citation.cfm?doid=42282.42283},
	doi = {10.1145/42282.42283},
	abstract = {The concept of partial synchrony in a distributed system is introduced. Partial synchrony lies between the cases of a synchronous system and an asynchronous system. In a synchronous system, there is a known fixed upper bound A on the time required for a messageto be sent from one processor to another and a known fixed upper bound \% on the relative speeds of different processors. In an asynchronous system no fixed upper bounds A and @exist. In one version of partial synchrony, fixed bounds A and Cpexist, but they are not known a priori. The problem is to design protocols that work correctly in the partially synchronous system regardlessof the actual values of the bounds A and Cp.In another version of partial synchrony, the bounds are known, but are only guaranteed to hold starting at some unknown time T, and protocols must be designed to work correctly regardlessof when time T occurs. Fault-tolerant consensusprotocols are given for various casesof partial synchrony and various fault models. Lower bounds that show in most casesthat our protocols are optimal with respect to the number of faults tolerated are also given. Our consensusprotocols for partially synchronous processors use new protocols for fault-tolerant “distributed clocks” that allow partially synchronous processorsto reach some approximately common notion of time.},
	language = {en},
	number = {2},
	urldate = {2019-05-05},
	journal = {Journal of the ACM},
	author = {Dwork, Cynthia and Lynch, Nancy and Stockmeyer, Larry},
	month = apr,
	year = {1988},
	pages = {288--323},
	file = {Dwork et al. - 1988 - Consensus in the presence of partial synchrony.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/8R2QSVKA/Dwork et al. - 1988 - Consensus in the presence of partial synchrony.pdf:application/pdf},
}

@article{crain_evaluating_2018,
	title = {Evaluating the {Red} {Belly} {Blockchain}},
	url = {http://arxiv.org/abs/1812.11747},
	abstract = {In this paper, we present the most extensive evaluation of blockchain system to date. To achieve scalability across servers in more than 10 countries located on 4 different continents, we drastically revisited Byzantine fault tolerant blockchains and verification of signatures. The resulting blockchain, called the Red Belly Blockchain (RBBC), commits more than a hundred thousand transactions issued by permissionless nodes. These transactions are grouped into blocks within few seconds through a partially synchronous consensus run by permissioned nodes. It prevents double spending by guaranteeing that a unique block is decided at any given index of the chain in a deterministic way by all participants. We compared the performance of RBBC against traditional Byzantine fault tolerant alternatives and more recent randomized solutions. In the same geo-distributed environment with low-end machines, we noticed two interesting comparisons: (i) the RBBC throughput scales to hundreds of machines whereas the classic 3-step leader-based BFT state machine used by consortium blockchains cannot scale to 40 identically configured nodes; (ii) RBBC guarantees transaction finality in 3 seconds and experiences a third of the latency that randomized-based solutions like HoneyBadgerBFT can offer. This empirical evaluation demonstrates that blockchain scalability can be achieved without sacrificing security.},
	urldate = {2019-05-05},
	journal = {arXiv:1812.11747 [cs]},
	author = {Crain, Tyler and Natoli, Christopher and Gramoli, Vincent},
	month = dec,
	year = {2018},
	note = {arXiv: 1812.11747},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {arXiv\:1812.11747 PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/98SYGKYT/Crain et al. - 2018 - Evaluating the Red Belly Blockchain.pdf:application/pdf;arXiv.org Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/9L7NPRJB/1812.html:text/html},
}

@techreport{chen_algorand_2018,
	title = {{ALGORAND} {AGREEMENT}: {Super} {Fast} and {Partition} {Resilient} {Byzantine} {Agreement}},
	shorttitle = {{ALGORAND} {AGREEMENT}},
	url = {http://eprint.iacr.org/2018/377},
	abstract = {We present a simple Byzantine agreement protocol with leader election, that works under {\textgreater} 2/3 honest majority and does not rely on the participants having synchronized clocks. When honest messages are delivered within a bounded worst-case delay, agreement is reached in expected constant number of steps when the elected leader is malicious, and is reached after two steps when the elected leader is honest. Our protocol is resilient to arbitrary network partitions with unknown length, and recovers fast after the partition is resolved and bounded message delay is restored. We will briefly discuss how the protocol applies to blockchains in a permissionless system. In particular, when an honest leader proposes a block of transactions, the first voting step happens in parallel with the block propagation. Effectively, after the block propagates, a certificate is generated in just one step of voting.},
	number = {377},
	urldate = {2019-05-05},
	author = {Chen, Jing and Gorbunov, Sergey and Micali, Silvio and Vlachos, Georgios},
	year = {2018},
	keywords = {blockchain, Byzantine agreement, consensus, proof-of-stake},
	file = {ePrint IACR Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/QQIV22GB/Chen et al. - 2018 - ALGORAND AGREEMENT Super Fast and Partition Resil.pdf:application/pdf;ePrint IACR Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/K5DBE7AP/377.html:text/html},
}

@article{charron-bost_formal_2009,
	title = {Formal verification of a {Consensus} algorithm in the {Heard}-{Of} model},
	abstract = {Distributed algorithms are subtle and error-prone. Still, very few of them have been formally verified, most algorithm designers only giving rough and informal sketches of proofs. We believe that this unsatisfactory situation is due to a scalability problem of current formal methods and that a simpler model is needed to reason about distributed algorithms. We consider formal verification of algorithms expressed in the Heard-Of model recently introduced by Charron-Bost and Schiper. As a concrete case study, we report on the formal verification of a non-trivial Consensus algorithm using the proof assistant Isabelle/HOL. 1},
	journal = {Intl. J. Software and Informatics},
	author = {Charron-bost, Bernadette and Merz, Stephan},
	year = {2009},
	file = {Citeseer - Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/QZ56TDMC/Charron-bost and Merz - 2009 - Formal verification of a Consensus algorithm in th.pdf:application/pdf;Citeseer - Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/U9X9ZKSH/summary.html:text/html},
}

@article{bouajjani_completeness_2018,
	title = {On the {Completeness} of {Verifying} {Message} {Passing} {Programs} under {Bounded} {Asynchrony}},
	url = {http://arxiv.org/abs/1804.06612},
	abstract = {We address the problem of verifying message passing programs, defined as a set of parallel processes communicating through unbounded FIFO buffers. We introduce a bounded analysis that explores a special type of computations, called k-synchronous. These computations can be viewed as (unbounded) sequences of interaction phases, each phase allowing at most k send actions (by different processes), followed by a sequence of receives corresponding to sends in the same phase. We give a procedure for deciding k-synchronizability of a program, i.e., whether every computation is equivalent (has the same happens-before relation) to one of its k-synchronous computations. We also show that reachability over k-synchronous computations and checking k-synchronizability are both PSPACE-complete. Furthermore, we introduce a class of programs called \{{\textbackslash}em flow-bounded\} for which the problem of deciding whether there exists a k{\textgreater}0 for which the program is k-synchronizable, is decidable.},
	urldate = {2019-05-05},
	journal = {arXiv:1804.06612 [cs]},
	author = {Bouajjani, Ahmed and Enea, Constantin and Ji, Kailiang and Qadeer, Shaz},
	month = apr,
	year = {2018},
	note = {arXiv: 1804.06612},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	file = {arXiv\:1804.06612 PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/ATHRNDKC/Bouajjani et al. - 2018 - On the Completeness of Verifying Message Passing P.pdf:application/pdf;arXiv.org Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/4M7UF54K/1804.html:text/html},
}

@incollection{hutchison_logic-based_2014,
	address = {Berlin, Heidelberg},
	title = {A {Logic}-{Based} {Framework} for {Verifying} {Consensus} {Algorithms}},
	volume = {8318},
	isbn = {978-3-642-54012-7 978-3-642-54013-4},
	url = {http://link.springer.com/10.1007/978-3-642-54013-4_10},
	abstract = {Fault-tolerant distributed algorithms play an important role in ensuring the reliability of many software applications. In this paper we consider distributed algorithms whose computations are organized in rounds. To verify the correctness of such algorithms, we reason about (i) properties (such as invariants) of the state, (ii) the transitions controlled by the algorithm, and (iii) the communication graph. We introduce a logic that addresses these points, and contains set comprehensions with cardinality constraints, function symbols to describe the local states of each process, and a limited form of quantiﬁer alternation to express the veriﬁcation conditions. We show its use in automating the veriﬁcation of consensus algorithms. In particular, we give a semi-decision procedure for the unsatisﬁability problem of the logic and identify a decidable fragment.We successfully applied our framework to verify the correctness of a variety of consensus algorithms tolerant to both benign faults (message loss, process crashes) and value faults (message corruption).},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}},
	publisher = {Springer Berlin Heidelberg},
	author = {Drăgoi, Cezara and Henzinger, Thomas A. and Veith, Helmut and Widder, Josef and Zufferey, Damien},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and McMillan, Kenneth L. and Rival, Xavier},
	year = {2014},
	doi = {10.1007/978-3-642-54013-4_10},
	pages = {161--181},
	file = {Drăgoi et al. - 2014 - A Logic-Based Framework for Verifying Consensus Al.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TAWUKZTQ/Drăgoi et al. - 2014 - A Logic-Based Framework for Verifying Consensus Al.pdf:application/pdf},
}

@article{lamport_temporal_1994,
	title = {The temporal logic of actions},
	volume = {16},
	issn = {01640925},
	url = {http://portal.acm.org/citation.cfm?doid=177492.177726},
	doi = {10.1145/177492.177726},
	language = {en},
	number = {3},
	urldate = {2019-05-05},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Lamport, Leslie},
	month = may,
	year = {1994},
	pages = {872--923},
	file = {Lamport - 1994 - The temporal logic of actions.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/IRVYLXJ6/Lamport - 1994 - The temporal logic of actions.pdf:application/pdf},
}

@article{pease_reaching_1980,
	title = {Reaching {Agreement} in the {Presence} of {Faults}},
	volume = {27},
	issn = {00045411},
	url = {http://portal.acm.org/citation.cfm?doid=322186.322188},
	doi = {10.1145/322186.322188},
	language = {en},
	number = {2},
	urldate = {2019-05-05},
	journal = {Journal of the ACM},
	author = {Pease, M. and Shostak, R. and Lamport, L.},
	month = apr,
	year = {1980},
	pages = {228--234},
	file = {Pease et al. - 1980 - Reaching Agreement in the Presence of Faults.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/8ZWG4BYD/Pease et al. - 1980 - Reaching Agreement in the Presence of Faults.pdf:application/pdf},
}

@article{lipton_reduction:_1975,
	title = {Reduction: a method of proving properties of parallel programs},
	volume = {18},
	issn = {00010782},
	shorttitle = {Reduction},
	url = {http://portal.acm.org/citation.cfm?doid=361227.361234},
	doi = {10.1145/361227.361234},
	abstract = {When proving that a parallel program has a given property it is often convenient to assume that a statement is indivisible, i.e. that the statement cannot be interleaved with the rest of the program. Here sufficient conditions are obtained to show that the assumption that a statement is indivisible can be relaxed and still preserve properties such as halting. Thus correctness proofs of a parallel system can often be greatly simplified.},
	language = {en},
	number = {12},
	urldate = {2019-05-05},
	journal = {Communications of the ACM},
	author = {Lipton, Richard J.},
	month = dec,
	year = {1975},
	pages = {717--721},
	file = {Lipton - 1975 - Reduction a method of proving properties of paral.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/4I3QSFII/Lipton - 1975 - Reduction a method of proving properties of paral.pdf:application/pdf},
}

@inproceedings{hawblitzel_ironfleet:_2015,
	address = {Monterey, California},
	title = {{IronFleet}: proving practical distributed systems correct},
	isbn = {978-1-4503-3834-9},
	shorttitle = {{IronFleet}},
	url = {http://dl.acm.org/citation.cfm?doid=2815400.2815428},
	doi = {10.1145/2815400.2815428},
	abstract = {Distributed systems are notorious for harboring subtle bugs. Veriﬁcation can, in principle, eliminate these bugs a priori, but veriﬁcation has historically been difﬁcult to apply at fullprogram scale, much less distributed-system scale.},
	language = {en},
	urldate = {2019-05-05},
	booktitle = {Proceedings of the 25th {Symposium} on {Operating} {Systems} {Principles} - {SOSP} '15},
	publisher = {ACM Press},
	author = {Hawblitzel, Chris and Howell, Jon and Kapritsos, Manos and Lorch, Jacob R. and Parno, Bryan and Roberts, Michael L. and Setty, Srinath and Zill, Brian},
	year = {2015},
	pages = {1--17},
	file = {Hawblitzel et al. - 2015 - IronFleet proving practical distributed systems c.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ZF723EBQ/Hawblitzel et al. - 2015 - IronFleet proving practical distributed systems c.pdf:application/pdf},
}

@article{lamport_byzantine_1982,
	title = {The {Byzantine} {Generals} {Problem}},
	volume = {4},
	issn = {01640925},
	url = {http://portal.acm.org/citation.cfm?doid=357172.357176},
	doi = {10.1145/357172.357176},
	language = {en},
	number = {3},
	urldate = {2019-05-05},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
	month = jul,
	year = {1982},
	pages = {382--401},
	file = {Lamport et al. - 1982 - The Byzantine Generals Problem.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/G9QVLAWW/Lamport et al. - 1982 - The Byzantine Generals Problem.pdf:application/pdf},
}

@article{lamport_time_1978,
	title = {Time, clocks, and the ordering of events in a distributed system},
	volume = {21},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=359545.359563},
	doi = {10.1145/359545.359563},
	abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
	language = {en},
	number = {7},
	urldate = {2019-05-05},
	journal = {Communications of the ACM},
	author = {Lamport, Leslie},
	month = jul,
	year = {1978},
	pages = {558--565},
	file = {Lamport - 1978 - Time, clocks, and the ordering of events in a dist.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VJSW5A9B/Lamport - 1978 - Time, clocks, and the ordering of events in a dist.pdf:application/pdf},
}

@book{lamport_specifying_2003,
	address = {Boston},
	title = {Specifying systems: the {TLA}+ language and tools for hardware and software engineers},
	isbn = {978-0-321-14306-8},
	shorttitle = {Specifying systems},
	language = {en},
	publisher = {Addison-Wesley},
	author = {Lamport, Leslie},
	year = {2003},
	keywords = {Computer systems, Logic, Symbolic and mathematical, Specifications, System design},
	file = {Lamport - 2003 - Specifying systems the TLA+ language and tools fo.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/WLTHZZ7H/Lamport - 2003 - Specifying systems the TLA+ language and tools fo.pdf:application/pdf},
}

@article{mukherjee_learning-based_2020,
	title = {Learning-based controlled concurrency testing},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3428298},
	doi = {10.1145/3428298},
	abstract = {SUVAM MUKHERJEE, Microsoft Research, India PANTAZIS DELIGIANNIS, Microsoft Research, USA ARPITA BISWAS, Indian Institute of Science, India AKASH LAL, Microsoft Research, India Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to łinterestingž subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice. In this paper, we present QL, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated QL on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found QL to consistently outperform the state-of-the-art in CCT. CCS Concepts: • Computing methodologies → Reinforcement learning; • Software and its engineering → Software testing and debugging.},
	language = {en},
	number = {OOPSLA},
	urldate = {2022-06-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Mukherjee, Suvam and Deligiannis, Pantazis and Biswas, Arpita and Lal, Akash},
	month = nov,
	year = {2020},
	pages = {1--31},
	file = {Mukherjee et al. - 2020 - Learning-based controlled concurrency testing.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TTL75YL4/Mukherjee et al. - 2020 - Learning-based controlled concurrency testing.pdf:application/pdf},
}

@inproceedings{mukherjee_learning-based_2020-1,
	title = {Learning-based {Controlled} {Concurrency} {Testing}},
	url = {https://www.microsoft.com/en-us/research/publication/learning-based-controlled-concurrency-testing/},
	abstract = {Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to “interesting” […]},
	language = {en-US},
	urldate = {2022-06-06},
	author = {Mukherjee, Suvam and Deligiannis, Pantazis and Biswas, Arpita and Lal, Akash},
	month = oct,
	year = {2020},
	file = {Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/URFAVZEC/learning-based-controlled-concurrency-testing.html:text/html},
}

@article{bertran_formal_2007,
	title = {Formal {Sequentialization} of {Distributed} {Systems} via {Program} {Rewriting}},
	volume = {188},
	doi = {10.1016/j.entcs.2007.05.038},
	abstract = {Formal sequentialization is introduced as a rewriting process for the reduction of parallelism and internal communication statements of distributed imperative programs. It constructs an equivalence proof in an implicit way, via the application of equivalence laws as rewrite rules, thus generating a chain of equivalent programs. The variety of the possible sequentialization degrees which are attainable is illustrated with an example. The approach is static, thus avoiding the state explosion problem, has an impressive state-vector reduction in many cases, and could be combined, as a model simplification step, with model checking and interactive theorem proving in system verification. Prior grounding results needed in formal sequential- ization are overviewed; more specifically, an algorithm for the automatic elimination of communications under the scope of sequential and parallel compositions, elimination laws which the algorithm applies, and a suitable equivalence criterion for the sequentialization process. The main contribution of this work is the extension of these results to encompass the formal elimination of both synchronous communications embedded within a subclass of selection statements, and of non-disjoint synchronous communication pairs. None of these cases has been treated in the literature before, and their solution considerably widens the application domain of formal sequentialization.},
	journal = {Electr. Notes Theor. Comput. Sci.},
	author = {Bertran, Miquel and Babot, Francesc-Xavier and Climent, August},
	month = jul,
	year = {2007},
	pages = {53--75},
	file = {Full Text:/home/pato/snap/zotero-snap/common/Zotero/storage/Y7SM9FQ2/Bertran et al. - 2007 - Formal Sequentialization of Distributed Systems vi.pdf:application/pdf},
}

@inproceedings{deligiannis_uncovering_2016,
	title = {Uncovering {Bugs} in {Distributed} {Storage} {Systems} during {Testing} (not in {Production}!)},
	url = {https://www.microsoft.com/en-us/research/publication/uncovering-bugs-in-distributed-storage-systems-during-testing-not-in-production/},
	abstract = {Testing distributed systems is challenging due to multiple sources of nondeterminism. Conventional testing techniques, such as unit, integration and stress testing, are ineffective in preventing serious but subtle bugs from reaching production. Formal techniques, such as TLA+, can only verify high-level specifications of systems at the level of logic-based models, and fall short of checking […]},
	language = {en-US},
	urldate = {2022-05-20},
	author = {Deligiannis, Pantazis and McCutchen, Matt and Thomson, Paul and Chen, Shuo and Donaldson, Alastair F. and Erickson, John and Huang, Cheng and Lal, Akash and Mudduluru, Rashmi and Qadeer, Shaz and Schulte, Wolfram},
	year = {2016},
	file = {Deligiannis et al. - Uncovering Bugs in Distributed Storage Systems dur.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TAHF3TQB/Deligiannis et al. - Uncovering Bugs in Distributed Storage Systems dur.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/NEWH5MXI/uncovering-bugs-in-distributed-storage-systems-during-testing-not-in-production.html:text/html},
}

@article{astrauskas_leveraging_2019,
	title = {Leveraging rust types for modular specification and verification},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360573},
	doi = {10.1145/3360573},
	abstract = {CCS Concepts: • General and reference → Verification; • Theory of computation → Programming logic; Separation logic; Program specifications; Program verification; • Software and its engineering → Software verification; Formal software verification.},
	language = {en},
	number = {OOPSLA},
	urldate = {2022-03-04},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
	month = oct,
	year = {2019},
	pages = {1--30},
	file = {Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/8XNE8NNV/Astrauskas et al. - 2019 - Leveraging rust types for modular specification an.pdf:application/pdf},
}

@article{ohearn_resources_nodate,
	title = {Resources, {Concurrency} and {Local} {Reasoning}},
	abstract = {In this paper we show how a resource-oriented logic, separation logic, can be used to reason about the usage of resources in concurrent programs.},
	language = {en},
	author = {O’Hearn, Peter W},
	pages = {19},
}

@inproceedings{ohearn_resources_2004,
	title = {Resources, {Concurrency} and {Local} {Reasoning}},
	volume = {375},
	isbn = {978-3-540-21313-0},
	doi = {10.1007/978-3-540-28644-8_4},
	abstract = {In the 1960s Dijkstra suggested that, in order to limit the complexity of potential process interactions, concurrent programs should be designed so that different processes behave independently, except at rare moments of synchronization [3]. Then, in the 1970s Hoare and Brinch Hansen argued that debugging and reasoning about concurrent programs could be considerably simplified using compiler-enforceable syntactic constraints that preclude interference [4,1]; scope restrictions were described which had the effect that all process interaction was mediated by a critical region or monitor. Based on such restrictions Hoare described proof rules for shared-variable concurrency that were beautifully modular [4]: one could reason locally about a process, and simple syntactic checks ensured that no other process could tamper with its state in a way that invalidated the local reasoning.},
	author = {O'Hearn, Peter},
	month = sep,
	year = {2004},
	pages = {49--67},
	file = {O’Hearn - Resources, Concurrency and Local Reasoning.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/W6MHYBZY/O’Hearn - Resources, Concurrency and Local Reasoning.pdf:application/pdf},
}

@book{klabnik_rust_2018,
	address = {San Francisco},
	edition = {1st Edition},
	title = {The {Rust} {Programming} {Language}},
	isbn = {978-1-59327-828-1},
	language = {English},
	publisher = {No Starch Press},
	author = {Klabnik, Steve and Nichols, Carol},
	month = jun,
	year = {2018},
	file = {Abnik and Nichols - The Rust Programming Language.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ISZ44XSK/Abnik and Nichols - The Rust Programming Language.pdf:application/pdf},
}

@article{abnik_rust_nodate,
	title = {The {Rust} {Programming} {Language}},
	language = {en},
	author = {Abnik, Steve Kl and Nichols, Carol},
	pages = {554},
}

@inproceedings{lokhava_fast_2019,
	address = {Huntsville Ontario Canada},
	title = {Fast and secure global payments with {Stellar}},
	isbn = {978-1-4503-6873-5},
	url = {https://dl.acm.org/doi/10.1145/3341301.3359636},
	doi = {10.1145/3341301.3359636},
	abstract = {International payments are slow and expensive, in part because of multi-hop payment routing through heterogeneous banking systems. Stellar is a new global payment network that can directly transfer digital money anywhere in the world in seconds. The key innovation is a secure transaction mechanism across untrusted intermediaries, using a new Byzantine agreement protocol called SCP. With SCP, each institution specifies other institutions with which to remain in agreement; through the global interconnectedness of the financial system, the whole network then agrees on atomic transactions spanning arbitrary institutions, with no solvency or exchange-rate risk from intermediary asset issuers or market makers. We present SCP’s model, protocol, and formal verification; describe the Stellar payment network; and finally evaluate Stellar empirically through benchmarks and our experience with several years of production use.},
	language = {en},
	urldate = {2022-02-16},
	booktitle = {Proceedings of the 27th {ACM} {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {ACM},
	author = {Lokhava, Marta and Losa, Giuliano and Mazières, David and Hoare, Graydon and Barry, Nicolas and Gafni, Eli and Jove, Jonathan and Malinowsky, Rafał and McCaleb, Jed},
	month = oct,
	year = {2019},
	pages = {80--96},
	file = {Lokhava et al. - 2019 - Fast and secure global payments with Stellar.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/DMANJ2U5/Lokhava et al. - 2019 - Fast and secure global payments with Stellar.pdf:application/pdf},
}

@article{buchman_latest_2018,
	title = {The latest gossip on {BFT} consensus},
	url = {https://arxiv.org/abs/1807.04938v3},
	abstract = {The paper presents Tendermint, a new protocol for ordering events in a distributed network under adversarial conditions. More commonly known as Byzantine Fault Tolerant (BFT) consensus or atomic broadcast, the problem has attracted significant attention in recent years due to the widespread success of blockchain-based digital currencies, such as Bitcoin and Ethereum, which successfully solved the problem in a public setting without a central authority. Tendermint modernizes classic academic work on the subject and simplifies the design of the BFT algorithm by relying on a peer-to-peer gossip protocol among nodes.},
	language = {en},
	urldate = {2022-02-14},
	author = {Buchman, Ethan and Kwon, Jae and Milosevic, Zarko},
	month = jul,
	year = {2018},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/H3DPWBFV/Buchman et al. - 2018 - The latest gossip on BFT consensus.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/SFE8DZRG/1807.html:text/html},
}

@article{ramalingam_context-sensitive_2000,
	title = {Context-sensitive synchronization-sensitive analysis is undecidable},
	volume = {22},
	issn = {0164-0925},
	url = {https://doi.org/10.1145/349214.349241},
	doi = {10.1145/349214.349241},
	abstract = {Static program analysis is concerned with the computation of approximations of the runtime behavior of programs. Precise information about a program's runtime behavior is, in general, uncomputable for various different reasons, and each reason may necessitate making certain approximations in the information computed. This article illustrates one source of difficulty in static analysis of concurrent programs. Specifically, the article shows that an analysis that is simultaneously both context-sensitive and synchronization-sensitive (that is, a context-sensitive analysis that precisely takes into account the constraints on execution order imposed by the synchronization statements in the program) is impossible even for the simplest of analysis problems.},
	number = {2},
	urldate = {2022-02-09},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Ramalingam, G.},
	month = mar,
	year = {2000},
	pages = {416--430},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/MJ3JWM6Y/Ramalingam - 2000 - Context-sensitive synchronization-sensitive analys.pdf:application/pdf},
}

@article{ramalingam_context-sensitive_2000-1,
	title = {Context-sensitive synchronization-sensitive analysis is undecidable},
	volume = {22},
	url = {https://www.microsoft.com/en-us/research/publication/context-sensitive-synchronization-sensitive-analysis-undecidable/},
	abstract = {Static program analysis is concerned with the computation of approximations of the runtime behavior of programs. Precise information about a program’s runtime behavior is, in general, uncomputable for various different reasons, and each reason may necessitate making certain approximations in the information computed. This article illustrates one source of difficulty in static analysis of concurrent […]},
	language = {en-US},
	number = {2},
	urldate = {2022-02-09},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Ramalingam, G.},
	month = mar,
	year = {2000},
	pages = {416--430},
	file = {Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/JVVMAM6E/context-sensitive-synchronization-sensitive-analysis-undecidable.html:text/html},
}

@article{krinke_context-sensitive_2003,
	title = {Context-sensitive slicing of concurrent programs},
	volume = {28},
	issn = {0163-5948},
	url = {https://doi.org/10.1145/949952.940096},
	doi = {10.1145/949952.940096},
	abstract = {Program slicing is a technique to identify statements that may influence the computations at other statements. Precise slicing has been shown to be undecidable for concurrent programs. This work presents the first context-sensitive approach to slice concurrent programs accurately. It extends the well known structures of the control flow graph and the (interprocedural) program dependence graph for concurrent programs with interference. This new technique does not require serialization or inlining.},
	number = {5},
	urldate = {2022-02-09},
	journal = {ACM SIGSOFT Software Engineering Notes},
	author = {Krinke, Jens},
	month = sep,
	year = {2003},
	keywords = {concurrency, context-sensitive, parallelism, program analysis, program slicing},
	pages = {178--187},
}

@article{ramalingam_context-sensitive_2000-2,
	title = {Context-sensitive synchronization-sensitive analysis is undecidable},
	doi = {10.1145/349214.349241},
	abstract = {The article shows that an analysis that is simultaneously both context-sensitive and synchronization-sensitive (that is, a context- sensitive analysis that precisely takes into account the constraints on execution order imposed by the synchronization statements in the program) is impossible even for the simplest of analysis problems. Static program analysis is concerned with the computation of approximations of the runtime behavior of programs. Precise information about a program's runtime behavior is, in general, uncomputable for various different reasons, and each reason may necessitate making certain approximations in the information computed. This article illustrates one source of difficulty in static analysis of concurrent programs. Specifically, the article shows that an analysis that is simultaneously both context-sensitive and synchronization-sensitive (that is, a context-sensitive analysis that precisely takes into account the constraints on execution order imposed by the synchronization statements in the program) is impossible even for the simplest of analysis problems.},
	journal = {TOPL},
	author = {Ramalingam, G.},
	year = {2000},
}

@inproceedings{bokor_efficient_2011,
	title = {Efficient model checking of fault-tolerant distributed protocols},
	doi = {10.1109/DSN.2011.5958208},
	abstract = {To aid the formal verification of fault-tolerant distributed protocols, we propose an approach that significantly reduces the costs of their model checking. These protocols often specify atomic, process-local events that consume a set of messages, change the state of a process, and send zero or more messages. We call such events quorum transitions and leverage them to optimize state exploration in two ways. First, we generate fewer states compared to models where quorum transitions are expressed by single-message transi- tions. Second, we refine transitions into a set of equivalent, finer-grained transitions that allow partial-order algorithms to achieve better reduction. We implement the MP-Basset model checker, which supports refined quorum transitions. We model check protocols representing core primitives of deployed reliable distributed systems, namely: Paxos consensus, regular storage, and Byzantine-tolerant multicast. We achieve up to 92\% memory and 85\% time reduction compared to model checking with standard unrefined single-message transitions.},
	author = {Bokor, Péter and Kinder, Johannes and Serafini, Marco and Suri, Neeraj},
	month = jun,
	year = {2011},
	pages = {73--84},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/ZXTVIZV4/Bokor et al. - 2011 - Efficient model checking of fault-tolerant distrib.pdf:application/pdf},
}

@inproceedings{qadeer_context-bounded_2005,
	address = {Berlin, Heidelberg},
	series = {{TACAS}'05},
	title = {Context-{Bounded} model checking of concurrent software},
	isbn = {978-3-540-25333-4},
	url = {https://doi.org/10.1007/978-3-540-31980-1_7},
	doi = {10.1007/978-3-540-31980-1_7},
	abstract = {The interaction among concurrently executing threads of a program results in insidious programming errors that are difficult to reproduce and fix. Unfortunately, the problem of verifying a concurrent boolean program is undecidable [24]. In this paper, we prove that the problem is decidable, even in the presence of unbounded parallelism, if the analysis is restricted to executions in which the number of context switches is bounded by an arbitrary constant. Restricting the analysis to executions with a bounded number of context switches is unsound. However, the analysis can still discover intricate bugs and is sound up to the bound since within each context, a thread is fully explored for unbounded stack depth. We present an analysis of a real concurrent system by the ZING model checker which demonstrates that the ability to model check with arbitrary but fixed context bound in the presence of unbounded parallelism is valuable in practice. Implementing context-bounded model checking in ZING is left for future work.},
	urldate = {2022-02-02},
	booktitle = {Proceedings of the 11th international conference on {Tools} and {Algorithms} for the {Construction} and {Analysis} of {Systems}},
	publisher = {Springer-Verlag},
	author = {Qadeer, Shaz and Rehof, Jakob},
	month = apr,
	year = {2005},
	pages = {93--107},
	file = {Full Text:/home/pato/snap/zotero-snap/common/Zotero/storage/W3HG4HSA/Qadeer and Rehof - 2005 - Context-Bounded model checking of concurrent softw.pdf:application/pdf},
}

@article{guo_practical_2011,
	title = {Practical software model checking via dynamic interface reduction},
	url = {https://www.microsoft.com/en-us/research/publication/practical-software-model-checking-via-dynamic-interface-reduction/},
	abstract = {Implementation-level software model checking explores the state space of a system implementation directly to find potential software defects without requiring any specification or modeling. Despite early successes, the effectiveness of this approach remains severely constrained due to poor scalability caused by state-space explosion. DEMETER makes software model checking more practical with the following contributions: (i) […]},
	language = {en-US},
	urldate = {2022-01-29},
	author = {Guo, Huayang and Wu, Ming and Zhou, Lidong and Hu, Gang and Yang, Junfeng and Zhang, Lintao},
	month = oct,
	year = {2011},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/KCDSXXBB/Guo et al. - 2011 - Practical software model checking via dynamic inte.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/XFFEUQN4/practical-software-model-checking-via-dynamic-interface-reduction.html:text/html},
}

@book{hopcroft_introduction_2006,
	address = {Boston},
	edition = {3rd edition},
	title = {Introduction to {Automata} {Theory}, {Languages}, and {Computation}},
	isbn = {978-0-321-45536-9},
	language = {English},
	publisher = {Pearson},
	author = {Hopcroft, John and Motwani, Rajeev and Ullman, Jeffrey},
	month = jun,
	year = {2006},
	file = {Hopcroft et al. - 2006 - Introduction to Automata Theory, Languages, and Co.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/RPXAPL7Z/Hopcroft et al. - 2006 - Introduction to Automata Theory, Languages, and Co.pdf:application/pdf},
}

@article{ramalingam_context-sensitive_2000-3,
	title = {Context-sensitive synchronization-sensitive analysis is undecidable},
	volume = {22},
	issn = {0164-0925},
	url = {https://doi.org/10.1145/349214.349241},
	doi = {10.1145/349214.349241},
	abstract = {Static program analysis is concerned with the computation of approximations of the runtime behavior of programs. Precise information about a program's runtime behavior is, in general, uncomputable for various different reasons, and each reason may necessitate making certain approximations in the information computed. This article illustrates one source of difficulty in static analysis of concurrent programs. Specifically, the article shows that an analysis that is simultaneously both context-sensitive and synchronization-sensitive (that is, a context-sensitive analysis that precisely takes into account the constraints on execution order imposed by the synchronization statements in the program) is impossible even for the simplest of analysis problems.},
	number = {2},
	urldate = {2022-01-27},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Ramalingam, G.},
	month = mar,
	year = {2000},
	pages = {416--430},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/S7DM5Q7J/Ramalingam - 2000 - Context-sensitive synchronization-sensitive analys.pdf:application/pdf},
}

@inproceedings{qadeer_kiss_2004,
	title = {{KISS}: {Keep} {It} {Simple} and {Sequential}},
	shorttitle = {{KISS}},
	url = {https://www.microsoft.com/en-us/research/publication/kiss-keep-simple-sequential/},
	abstract = {The design of concurrent programs is error-prone due to the interaction between concurrently executing threads. Traditional automated techniques for finding errors in concurrent programs, such as model checking, explore all possible thread interleavings. Since the number of thread interleavings increases exponentially with the number of threads, such analyses have high computational complexity. In this paper, […]},
	language = {en-US},
	urldate = {2022-01-26},
	author = {Qadeer, Shaz and Wu, Dinghao},
	month = jun,
	year = {2004},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/QHURS4YK/Qadeer and Wu - 2004 - KISS Keep It Simple and Sequential.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/8A4LV8DE/kiss-keep-simple-sequential.html:text/html},
}

@misc{noauthor_notitle_nodate,
}

@inproceedings{bouajjani_sequentializing_2011,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {On {Sequentializing} {Concurrent} {Programs}},
	isbn = {978-3-642-23702-7},
	doi = {10.1007/978-3-642-23702-7_13},
	abstract = {We propose a general framework for compositional underapproximate concurrent program analyses by reduction to sequential program analyses—so-called sequentializations. We notice the existing sequentializations—based on bounding the number of execution contexts, execution rounds, or delays from a deterministic task-schedule—rely on three key features for scalable concurrent program analyses: (i) reduction to the sequential program model, (ii) compositional reasoning to avoid expensive task-product constructions, and (iii) parameterized exploration bounds. To understand how those sequentializations can be unified and generalized, we define a general framework which preserves their key features, and in which those sequentializations are particular instances. We also identify a most general instance which considers more executions, by composing the rounds of different tasks in any order, restricted only by the unavoidable program and task-creation causality orders. In fact, we show this general instance is fundamentally more powerful by identifying an infinite family of state-reachability problems (to states g 1, g 2,...) which can be answered precisely with a fixed exploration bound, whereas the existing sequentializations require an increasing bound k to reach each g k . Our framework applies to a general class of shared-memory concurrent programs, with dynamic task-creation and arbitrary preemption.},
	language = {en},
	booktitle = {Static {Analysis}},
	publisher = {Springer},
	author = {Bouajjani, Ahmed and Emmi, Michael and Parlato, Gennaro},
	editor = {Yahav, Eran},
	year = {2011},
	keywords = {Compositional Semantic, Concurrent Program, Initial Valuation, Model Check Software, Sequential Program},
	pages = {129--145},
	file = {Accepted Version:/home/pato/snap/zotero-snap/common/Zotero/storage/8UKPWEZ9/Bouajjani et al. - 2011 - On Sequentializing Concurrent Programs.pdf:application/pdf},
}

@inproceedings{bouajjani_verifying_2013,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Verifying {Concurrent} {Programs} against {Sequential} {Specifications}},
	isbn = {978-3-642-37036-6},
	doi = {10.1007/978-3-642-37036-6_17},
	abstract = {We investigate the algorithmic feasibility of checking whether concurrent implementations of shared-memory objects adhere to their given sequential specifications; sequential consistency, linearizability, and conflict serializability are the canonical variations of this problem. While verifying sequential consistency of systems with unbounded concurrency is known to be undecidable, we demonstrate that conflict serializability, and linearizability with fixed linearization points are EXPSPACE-complete, while the general linearizability problem is undecidable.Our (un)decidability proofs, besides bestowing novel theoretical results, also reveal novel program explorations strategies. For instance, we show that every violation to conflict serializability is captured by a conflict cycle whose length is bounded independently from the number of concurrent operations. This suggests an incomplete detection algorithm which only remembers a small subset of conflict edges, which can be made complete by increasing the number of remembered edges to the cycle-length bound. Similarly, our undecidability proof for linearizability suggests an incomplete detection algorithm which limits the number of “barriers” bisecting non-overlapping operations. Our decidability proof of bounded-barrier linearizability is interesting on its own, as it reduces the consideration of all possible operation serializations to numerical constraint solving. The literature seems to confirm that most violations are detectable by considering very few conflict edges or barriers.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer},
	author = {Bouajjani, Ahmed and Emmi, Michael and Enea, Constantin and Hamza, Jad},
	editor = {Felleisen, Matthias and Gardner, Philippa},
	year = {2013},
	keywords = {Concurrent Program, Reachability Problem, Sequential Consistency, Serial Sequence, Transactional Memory},
	pages = {290--309},
	file = {Springer Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/U3Z9FUN9/Bouajjani et al. - 2013 - Verifying Concurrent Programs against Sequential S.pdf:application/pdf},
}

@inproceedings{biely_distal_2013,
	title = {Distal: {A} framework for implementing fault-tolerant distributed algorithms},
	shorttitle = {Distal},
	doi = {10.1109/DSN.2013.6575306},
	abstract = {We introduce Distal, a new framework that simplifies turning pseudocode of fault tolerant distributed algorithms into efficient executable code. Without proper tool support, even small amounts of pseudocode normally ends up in several thousands of non-trivial lines of Java or C++. Distal is implemented as a library in Scala and consists of two main parts: a domain specific language (DSL) in which algorithms are expressed and an efficient messaging layer that deals with low level issues such as connection management, threading and (de)serialization. The DSL is designed such that implementations of distributed algorithms highly resemble the pseudocode found in research papers. By writing code that is close to the protocol description, one can be more convinced that the implemented system really reflects the protocol specification on paper. Distal does not only make it simple and intuitive to implement distributed algorithms but it also leads to efficient implementations.},
	booktitle = {2013 43rd {Annual} {IEEE}/{IFIP} {International} {Conference} on {Dependable} {Systems} and {Networks} ({DSN})},
	author = {Biely, Martin and Delgado, Pamela and Milosevic, Zarko and Schiper, André},
	month = jun,
	year = {2013},
	note = {ISSN: 2158-3927},
	keywords = {Algorithm design and analysis, Distributed algorithms, DSL, Fault tolerance, Fault tolerant systems, fault-tolerant distributed algorithms, Java, Paxos, Protocols, SMR},
	pages = {1--8},
	file = {Biely et al. - 2013 - Distal A framework for implementing fault-toleran.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/DGD3KP25/Biely et al. - 2013 - Distal A framework for implementing fault-toleran.pdf:application/pdf;IEEE Xplore Abstract Record:/home/pato/snap/zotero-snap/common/Zotero/storage/YYTIKTZD/6575306.html:text/html},
}

@article{aguilera_correctness_2012,
	title = {The correctness proof of {Ben}-{Or}’s randomized consensus algorithm},
	volume = {25},
	issn = {1432-0452},
	url = {https://doi.org/10.1007/s00446-012-0162-z},
	doi = {10.1007/s00446-012-0162-z},
	abstract = {In a ground-breaking paper that appeared in 1983, Ben-Or presented the first randomized algorithm to solve consensus in an asynchronous message-passing system where processes can fail by crashing. Although more efficient randomized algorithms were subsequently proposed, Ben-Or’s algorithm is still the simplest and most elegant one. For this reason, it is often taught in distributed computing courses and it appears in several textbooks. Even though Ben-Or’s algorithm is widely known and it is very simple, surprisingly a proof of correctness of the algorithm has not yet appeared: previously published proofs make some simplifying assumptions—specifically, they either assume that f {\textless} n/3 (n is the total number of processes and f is maximum number of processes that may crash) or that the adversary is weak, that is, it cannot see the process states or the content of the messages. In this paper, we present a correctness proof for Ben-Or’s randomized consensus algorithm for the case that f {\textless} n/2 process crashes and the adversary is strong (i.e., it can see the process states and message contents, and schedule the process steps and message receipts accordingly). To the best of our knowledge, this is the first full proof of this classical algorithm. We also demonstrate a counterintuitive problem that may occur if one uses the well-known abstraction of a “global coin” to modularize and speed up randomized consensus algorithms, such as Ben-Or’s algorithm. Specifically, we show that contrary to common belief, the use of a global coin can sometimes be deleterious rather than beneficial: instead of speeding up Ben-Or’s algorithm, the use of a global coin in this algorithm may actually prevent termination.},
	language = {en},
	number = {5},
	urldate = {2021-11-24},
	journal = {Distributed Computing},
	author = {Aguilera, Marcos K. and Toueg, Sam},
	month = oct,
	year = {2012},
	pages = {371--381},
	file = {s00446-012-0162-z.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/LAEF6FHC/s00446-012-0162-z.pdf:application/pdf;Submitted Version:/home/pato/snap/zotero-snap/common/Zotero/storage/JJJZB2NI/Aguilera and Toueg - 2012 - The correctness proof of Ben-Or’s randomized conse.pdf:application/pdf},
}

@article{gray_consensus_2004,
	title = {Consensus on {Transaction} {Commit}},
	url = {https://www.microsoft.com/en-us/research/publication/consensus-on-transaction-commit/},
	abstract = {In [143], I announced some lower-bound results for the consensus problem. One result states that two message delays are required to choose a value, and a relatively large number of processors are needed to achieve that bound. When writing a careful proof of this result, I realized that it required the hypothesis that values proposed […]},
	language = {en-US},
	urldate = {2021-10-15},
	author = {Gray, Jim and Lamport, Leslie},
	month = jan,
	year = {2004},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/33BKI8N4/Gray and Lamport - 2004 - Consensus on Transaction Commit.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/Y73RLBYX/consensus-on-transaction-commit.html:text/html},
}

@article{lamport_interprocess_1985,
	title = {On {Interprocess} {Communication}-{Part} {I}: {Basic} {Formalism}, {Part} {II}: {Algorithms}},
	shorttitle = {On {Interprocess} {Communication}-{Part} {I}},
	url = {https://www.microsoft.com/en-us/research/publication/interprocess-communication-part-basic-formalism-part-ii-algorithms/},
	abstract = {Most computer scientists regard synchronization problems, such as the mutual exclusion problem, to be problems of mathematics. How can you use one class of mathematical objects, like atomic reads and writes, to implement some other mathematical object, like a mutual exclusion algorithm? I have always regarded synchronization problems to be problems of physics. How do […]},
	language = {en-US},
	urldate = {2021-10-14},
	journal = {Distributed Computing. Also appeared as SRC Research Report 8.},
	author = {Lamport, Leslie},
	month = dec,
	year = {1985},
	pages = {77--101},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/VV3PW3UF/Lamport - 1985 - On Interprocess Communication-Part I Basic Formal.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/5SWA6RVA/interprocess-communication-part-basic-formalism-part-ii-algorithms.html:text/html},
}

@misc{fekete_need_1990,
	title = {The {Need} for {Headers}: {An} {Impossibility} {Result} for {Communication} over {Unreliable} {Channels}},
	shorttitle = {The {Need} for {Headers}},
	abstract = {It is proved that any protocol that constructs a reliable data link service using a physical channel service necessarily includes in the packets some header information that enables the protocol to treat different packets differently. The physical channel considered is permitted to lose, but not reorder or duplicate packets. The formal framework used for the proof is the I/O automaton model.},
	author = {Fekete, Alan and Lynch, Nancy},
	year = {1990},
	file = {Fekete and Lynch - The need for headers An impossibility result for .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/JXVMTITB/Fekete and Lynch - The need for headers An impossibility result for .pdf:application/pdf},
}

@inproceedings{peled_all_1993,
	title = {All from {One}, {One} for {All}: on {Model} {Checking} {Using} {Representatives}.},
	isbn = {978-3-540-56922-0},
	shorttitle = {All from {One}, {One} for {All}},
	abstract = {Checking that a given finite state program satisfies a linear temporal logic property is suffering in many cases from a severe space and time explosion. One way to cope with this is to reduce the state graph used for model checking. We define an equivalence relation between infinite sequences, based on infinite traces such that for each equivalence class, either all or none of the sequences satisfy the checked formula. We present an algorithm for constructing a state graph that contains at least one representative sequence for each equivalence class. This allows applying existing model checking algorithms to the reduced state graph rather than on the larger full state graph of the program. It also allows model checking under fairness assumptions, and exploits these assumptions to obtain smaller state graphs. A formula rewriting technique is presented to allow coarser equivalence relation among sequences, such that less representatives are needed.},
	author = {Peled, Doron},
	month = jun,
	year = {1993},
	pages = {409--423},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/3MV5X82J/Peled - 1993 - All from One, One for All on Model Checking Using.pdf:application/pdf},
}

@inproceedings{abdulla_verifying_1993,
	title = {Verifying {Programs} with {Unreliable} {Channels}},
	abstract = {We consider the verification of a particular class of infinite-state systems, namely systems consisting of finite-state processes that communicate via unbounded lossy FIFO channels. This class is able to model e.g. link protocols such as the Alternating Bit Protocol and HDLC. For this class of systems, we show that several interesting verification problems are decidable by giving algorithms for verifying (1) the reachability problem: is a finite set of global states reachable from some other global state of the system, (2) safety properties over traces formulated as regular sets of allowed finite traces, and (3) eventuality properties: do all computations of a system eventually reach a given set of states. We have used the algorithms to verify some idealized sliding-window protocols with reasonable time and space resources. Our results should be contrasted with the well-known fact that these problems are undecidable for systems with unbounded perfect FIFO channels.},
	booktitle = {Information and {Computation}},
	author = {Abdulla, Parosh and Jonsson, Bengt},
	year = {1993},
	pages = {160--170},
	file = {Citeseer - Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/MJTM8U56/Abdulla and Jonsson - 1993 - Verifying Programs with Unreliable Channels.pdf:application/pdf;Citeseer - Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/8CURFJSY/summary.html:text/html},
}

@article{holzmann_model_1997,
	title = {The model checker {SPIN}},
	volume = {23},
	issn = {1939-3520},
	doi = {10.1109/32.588521},
	abstract = {SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. The paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.},
	number = {5},
	journal = {IEEE Transactions on Software Engineering},
	author = {Holzmann, G.J.},
	month = may,
	year = {1997},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Algorithm design and analysis, Distributed algorithms, Application software, Concurrent computing, Control system synthesis, Design methodology, Error correction codes, Message passing, Software systems, Telephony},
	pages = {279--295},
	file = {IEEE Xplore Abstract Record:/home/pato/snap/zotero-snap/common/Zotero/storage/4BKBERC8/588521.html:text/html;ieee97.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VH5BZWJB/ieee97.pdf:application/pdf},
}

@misc{godefroid_partial-order_1995,
	title = {Partial-{Order} {Methods} for the {Verification} of {Concurrent} {Systems} - {An} {Approach} to the {State}-{Explosion} {Problem}},
	abstract = {State-space exploration techniques are increasingly being used for debugging and proving correct finite-state concurrent reactive systems. The reason for this success is mainly the simplicity of these techniques. Indeed, they are easy to understand, easy to implement and, last but not least, easy to use: they are fully automatic. Moreover, the range of properties that they can verify has been substantially broadened thanks to the development of model-checking methods for various temporal logics. The main limit of state-space exploration verification techniques is the often excessive size of the state space due, among other causes, to the modeling of concurrency by interleaving. However, exploring all interleavings of concurrent events is not a priori necessary for verification: interleavings corresponding to the same concurrent execution contain related information. One can thus hope to be able to verify properties of a concurrent system without exploring all interleavings of its concu...},
	author = {Godefroid, Patrice},
	year = {1995},
	file = {Citeseer - Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/NWKM6JP3/Godefroid - 1995 - Partial-Order Methods for the Verification of Conc.pdf:application/pdf;Citeseer - Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/U6KR8X7G/summary.html:text/html},
}

@article{majumdar_foundations_2014,
	title = {Foundations of {Infinite}-{State} {Verification}},
	url = {https://ebooks.iospress.nl/doi/10.3233/978-1-61499-385-8-191},
	doi = {10.3233/978-1-61499-385-8-191},
	urldate = {2021-09-07},
	journal = {Software Systems Safety},
	author = {Majumdar, Rupak},
	year = {2014},
	note = {Publisher: IOS Press},
	pages = {191--222},
	file = {Majumdar - 2014 - Foundations of Infinite-State Verification.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/DK8G6AVN/Majumdar - 2014 - Foundations of Infinite-State Verification.pdf:application/pdf},
}

@article{bakst_verifying_2017,
	title = {Verifying distributed programs via canonical sequentialization},
	volume = {1},
	url = {https://doi.org/10.1145/3133934},
	doi = {10.1145/3133934},
	abstract = {We introduce canonical sequentialization, a new approach to verifying unbounded, asynchronous, message-passing programs at compile-time. Our approach builds upon the following observation: due the combinatorial explosion in complexity, programmers do not reason about their systems by case-splitting over all the possible execution orders. Instead, correct programs tend to be well-structured so that the programmer can reason about a small number of representative executions, which we call the program’s canonical sequentialization. We have implemented our approach in a tool called Brisk that synthesizes canonical sequentializations for programs written in Haskell, and evaluated it on a wide variety of distributed systems including benchmarks from the literature and implementations of MapReduce, two-phase commit, and a version of the Disco distributed file-system. We show that unlike model checking, which gets prohibitively slow with just 10 processes Brisk verifies the unbounded versions of the benchmarks in tens of milliseconds, yielding the first concurrency verification tool that is fast enough to be integrated into a design-implement-check cycle.},
	number = {OOPSLA},
	urldate = {2021-07-26},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bakst, Alexander and Gleissenthall, Klaus v. and Kici, Rami Gökhan and Jhala, Ranjit},
	month = oct,
	year = {2017},
	keywords = {concurrency, asynchronous programs, canonical sequentialization, distributed programs, message passing, parameterized systems, program verification, reductions},
	pages = {110:1--110:27},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/9W7NDF5N/Bakst et al. - 2017 - Verifying distributed programs via canonical seque.pdf:application/pdf},
}

@inproceedings{oki_viewstamped_1988,
	address = {New York, NY, USA},
	series = {{PODC} '88},
	title = {Viewstamped {Replication}: {A} {New} {Primary} {Copy} {Method} to {Support} {Highly}-{Available} {Distributed} {Systems}},
	isbn = {978-0-89791-277-8},
	shorttitle = {Viewstamped {Replication}},
	url = {https://doi.org/10.1145/62546.62549},
	doi = {10.1145/62546.62549},
	urldate = {2021-08-22},
	booktitle = {Proceedings of the seventh annual {ACM} {Symposium} on {Principles} of distributed computing},
	publisher = {Association for Computing Machinery},
	author = {Oki, Brian M. and Liskov, Barbara H.},
	month = jan,
	year = {1988},
	pages = {8--17},
}

@article{charron-bost_heard-model_2009,
	title = {The {Heard}-{Of} model: computing in distributed systems with benign faults},
	volume = {22},
	issn = {0178-2770},
	shorttitle = {The {Heard}-{Of} model},
	url = {https://doi.org/10.1007/s00446-009-0084-6},
	doi = {10.1007/s00446-009-0084-6},
	abstract = {Problems in fault-tolerant distributed computing have been studied in a variety of models. These models are structured around two central ideas: (1) degree of synchrony and failure model are two independent parameters that determine a particular type of system, (2) the notion of faulty component is helpful and even necessary for the analysis of distributed computations when faults occur. In this work, we question these two basic principles of fault-tolerant distributed computing, and show that it is both possible and worthy to renounce them in the context of benign faults: we present a computational model based only on the notion of transmission faults. In this model, computations evolve in rounds, and messages missed in a round are lost. Only information transmission is represented: for each round r and each process p, our model provides the set of processes that p "hears of" at round r (heard-of set), namely the processes from which p receives some message at round r. The features of a specific system are thus captured as a whole, just by a predicate over the collection of heard-of sets. We show that our model handles benign failures, be they static or dynamic, permanent or transient, in a unified framework. We demonstrate how this approach leads to shorter and simpler proofs of important results (non-solvability, lower bounds). In particular, we prove that the Consensus problem cannot be generally solved without an implicit and permanent consensus on heard-of sets. We also examine Consensus algorithms in our model. In light of this specific agreement problem, we show how our approach allows us to devise new interesting solutions.},
	number = {1},
	urldate = {2021-08-22},
	journal = {Distributed Computing},
	author = {Charron-Bost, Bernadette and Schiper, André},
	month = apr,
	year = {2009},
	keywords = {Benign fault, Computational model, Consensus, HO (Heard-Of) model, Transmission fault},
	pages = {49--71},
	file = {Charron-Bost and Schiper - The Heard-Of Model Computing in Distributed Syste.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ZQGYIHTV/Charron-Bost and Schiper - The Heard-Of Model Computing in Distributed Syste.pdf:application/pdf;Submitted Version:/home/pato/snap/zotero-snap/common/Zotero/storage/UPA738A2/Charron-Bost and Schiper - 2009 - The Heard-Of model computing in distributed syste.pdf:application/pdf},
}

@phdthesis{rybalchenko_temporal_2005,
	title = {Temporal verification with transition invariants},
	abstract = {Abstract Program verification increases the degree of confidence that a program,will perform correctly. Manual verification is an error-prone and tediou s task. Its automation is highly desirable. The verification methodology,reduces the reasoning about temporal properties of program computations to testing the validity of implication between auxiliary first-order assertions. The synthesis of such auxili ary assertions is the main challenge for automated,tools. There already exist successful tools for the verification of safety properties. These properties require that some “bad” state s never appear during program computations. The tools construct invariants, which are auxiliary assertions for safety. Invariants are computed,symbolically by applying techniques of abstract interpretation. Liveness properties require that some “good” states will eventually appear in every computation. The synthesis of auxiliary assertions for the verification of liveness properties is the next challenge for automated,ver ification tools. This dissertation argues that transition invariants can provide a new basis for the development,of automated methods,for the verification of liv eness properties. We support this thesis as follows. We introduce a new notion of auxiliary assertions called transition invariant. We apply this notion to propose a proof rule for the verification of liveness properties. We provide a viable approach for the automated,synthesis of},
	author = {Rybalchenko, Andrey},
	month = jan,
	year = {2005},
	file = {Rybalchenko - zur Erlangung des Grades Doktor der Ingenieurwisse.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/G75CTAQF/Rybalchenko - zur Erlangung des Grades Doktor der Ingenieurwisse.pdf:application/pdf},
}

@inproceedings{podelski_transition_2004,
	address = {Turku, Finland},
	title = {Transition invariants},
	isbn = {978-0-7695-2192-3},
	url = {http://ieeexplore.ieee.org/document/1319598/},
	doi = {10.1109/LICS.2004.1319598},
	abstract = {Proof rules for program veriﬁcation rely on auxiliary assertions. We propose a (sound and relatively complete) proof rule whose auxiliary assertions are transition invariants. A transition invariant of a program is a binary relation over program states that contains the transitive closure of the transition relation of the program. A relation is disjunctively well-founded if it is a ﬁnite union of well-founded relations. We characterize the validity of termination or another liveness property by the existence of a disjunctively well-founded transition invariant. The main contribution of our proof rule lies in its potential for automation via abstract interpretation.},
	language = {en},
	urldate = {2021-08-05},
	booktitle = {Proceedings of the 19th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}, 2004.},
	publisher = {IEEE},
	author = {Podelski, A. and Rybalchenko, A.},
	year = {2004},
	pages = {32--41},
	file = {Podelski and Rybalchenko - 2004 - Transition invariants.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ZBW52I87/Podelski and Rybalchenko - 2004 - Transition invariants.pdf:application/pdf},
}

@misc{lampson_crash_1976,
	title = {Crash {Recovery} in a {Distributed} {Data} {Storage} {System}},
	abstract = {An algorithm is described which guarantees reliable storage of data in a distributed system, even when different portions of the data base, stored on separate machines, are updated as part of a single transaction. The algorithm is implemented by a hierarchy of rather simple abstractions, and it works properly regardless of crashes of the client or servers. Some care is taken to state precisely the assumptions about the physical components of the system (storage, processors and communication).},
	author = {Lampson, Butler and Lampson, {and} Butler W. and Sturgis, Howard E.},
	year = {1976},
	file = {Citeseer - Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/9Y266CAD/Lampson et al. - 1976 - Crash Recovery in a Distributed Data Storage Syste.pdf:application/pdf;Citeseer - Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/YJJJPMM7/summary.html:text/html},
}

@inproceedings{desai_p_2013,
	address = {New York, NY, USA},
	series = {{PLDI} '13},
	title = {P: safe asynchronous event-driven programming},
	isbn = {978-1-4503-2014-6},
	shorttitle = {P},
	url = {https://doi.org/10.1145/2491956.2462184},
	doi = {10.1145/2491956.2462184},
	abstract = {We describe the design and implementation of P, a domain-specific language to write asynchronous event driven code. P allows the programmer to specify the system as a collection of interacting state machines, which communicate with each other using events. P unifies modeling and programming into one activity for the programmer. Not only can a P program be compiled into executable code, but it can also be tested using model checking techniques. P allows the programmer to specify the environment, used to "close" the system during testing, as nondeterministic ghost machines. Ghost machines are erased during compilation to executable code; a type system ensures that the erasure is semantics preserving. The P language is designed so that a P program can be checked for responsiveness---the ability to handle every event in a timely manner. By default, a machine needs to handle every event that arrives in every state. But handling every event in every state is impractical. The language provides a notion of deferred events where the programmer can annotate when she wants to delay processing an event. The default safety checker looks for presence of unhandled events. The language also provides default liveness checks that an event cannot be potentially deferred forever. P was used to implement and verify the core of the USB device driver stack that ships with Microsoft Windows 8. The resulting driver is more reliable and performs better than its prior incarnation (which did not use P); we have more confidence in the robustness of its design due to the language abstractions and verification provided by P.},
	urldate = {2021-07-13},
	booktitle = {Proceedings of the 34th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Desai, Ankush and Gupta, Vivek and Jackson, Ethan and Qadeer, Shaz and Rajamani, Sriram and Zufferey, Damien},
	month = jun,
	year = {2013},
	keywords = {device driver, domain-specific language, event-driven programming, state machine, systematic testing, verification},
	pages = {321--332},
	file = {Desai et al. - P safe asynchronous event-driven programming.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/EWC6A62D/Desai et al. - P safe asynchronous event-driven programming.pdf:application/pdf},
}

@inproceedings{kragl_inductive_2020,
	address = {London UK},
	title = {Inductive sequentialization of asynchronous programs},
	isbn = {978-1-4503-7613-6},
	url = {https://dl.acm.org/doi/10.1145/3385412.3385980},
	doi = {10.1145/3385412.3385980},
	abstract = {Asynchronous programs are notoriously difficult to reason about because they spawn computation tasks which take effect asynchronously in a nondeterministic way. Devising inductive invariants for such programs requires understanding and stating complex relationships between an unbounded number of computation tasks in arbitrarily long executions. In this paper, we introduce inductive sequentialization, a new proof rule that sidesteps this complexity via a sequential reduction, a sequential program that captures every behavior of the original program up to reordering of coarse-grained commutative actions. A sequential reduction of a concurrent program is easy to reason about since it corresponds to a simple execution of the program in an idealized synchronous environment, where processes act in a fixed order and at the same speed. We have implemented and integrated our proof rule in the CIVL verifier, allowing us to provably derive fine-grained implementations of asynchronous programs. We have successfully applied our proof rule to a diverse set of message-passing protocols, including leader election protocols, two-phase commit, and Paxos.},
	language = {en},
	urldate = {2021-06-18},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Kragl, Bernhard and Enea, Constantin and Henzinger, Thomas A. and Mutluergil, Suha Orhun and Qadeer, Shaz},
	month = jun,
	year = {2020},
	pages = {227--242},
	file = {Kragl et al. - 2020 - Inductive sequentialization of asynchronous progra.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/LUJR4F62/Kragl et al. - 2020 - Inductive sequentialization of asynchronous progra.pdf:application/pdf},
}

@inproceedings{junqueira_zab_2011,
	address = {Hong Kong},
	title = {Zab: {High}-performance broadcast for primary-backup systems},
	isbn = {978-1-4244-9233-6 978-1-4244-9232-9 978-1-4244-9231-2},
	shorttitle = {Zab},
	url = {http://ieeexplore.ieee.org/document/5958223/},
	doi = {10.1109/DSN.2011.5958223},
	abstract = {Zab is a crash-recovery atomic broadcast algorithm we designed for the ZooKeeper coordination service. ZooKeeper implements a primary-backup scheme in which a primary process executes clients operations and uses Zab to propagate the corresponding incremental state changes to backup processes1. Due the dependence of an incremental state change on the sequence of changes previously generated, Zab must guarantee that if it delivers a given state change, then all other changes it depends upon must be delivered ﬁrst. Since primaries may crash, Zab must satisfy this requirement despite crashes of primaries. Applications using ZooKeeper demand high-performance from the service, and consequently, one important goal is the ability of having multiple outstanding client operations at a time. Zab enables multiple outstanding state changes by guaranteeing that at most one primary is able to broadcast state changes and have them incorporated into the state, and by using a synchronization phase while establishing a new primary. Before this synchronization phase completes, a new primary does not broadcast new state changes. Finally, Zab uses an identiﬁcation scheme for state changes that enables a process to easily identify missing changes. This feature is key for efﬁcient recovery.},
	language = {en},
	urldate = {2021-06-15},
	booktitle = {2011 {IEEE}/{IFIP} 41st {International} {Conference} on {Dependable} {Systems} \& {Networks} ({DSN})},
	publisher = {IEEE},
	author = {Junqueira, F. P. and Reed, B. C. and Serafini, M.},
	month = jun,
	year = {2011},
	pages = {245--256},
	file = {Junqueira et al. - 2011 - Zab High-performance broadcast for primary-backup.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/L7SEB44J/Junqueira et al. - 2011 - Zab High-performance broadcast for primary-backup.pdf:application/pdf},
}

@article{yin_hotstuff_2019,
	title = {{HotStuff}: {BFT} {Consensus} in the {Lens} of {Blockchain}},
	shorttitle = {{HotStuff}},
	url = {http://arxiv.org/abs/1803.05069},
	abstract = {We present HotStuff, a leader-based Byzantine fault-tolerant replication protocol for the partially synchronous model. Once network communication becomes synchronous, HotStuff enables a correct leader to drive the protocol to consensus at the pace of actual (vs. maximum) network delay--a property called responsiveness--and with communication complexity that is linear in the number of replicas. To our knowledge, HotStuff is the first partially synchronous BFT replication protocol exhibiting these combined properties. HotStuff is built around a novel framework that forms a bridge between classical BFT foundations and blockchains. It allows the expression of other known protocols (DLS, PBFT, Tendermint, Casper), and ours, in a common framework. Our deployment of HotStuff over a network with over 100 replicas achieves throughput and latency comparable to that of BFT-SMaRt, while enjoying linear communication footprint during leader failover (vs. quadratic with BFT-SMaRt).},
	urldate = {2021-06-09},
	journal = {arXiv:1803.05069 [cs]},
	author = {Yin, Maofan and Malkhi, Dahlia and Reiter, Michael K. and Gueta, Guy Golan and Abraham, Ittai},
	month = jul,
	year = {2019},
	note = {arXiv: 1803.05069},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {arXiv Fulltext PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/K8VIUIUU/Yin et al. - 2019 - HotStuff BFT Consensus in the Lens of Blockchain.pdf:application/pdf;arXiv.org Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/NXCNQCCN/1803.html:text/html},
}

@article{nakamoto_bitcoin_2008,
	title = {Bitcoin: {A} {Peer}-to-{Peer} {Electronic} {Cash} {System}},
	abstract = {A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.},
	language = {en},
	author = {Nakamoto, Satoshi},
	month = oct,
	year = {2008},
	pages = {9},
	file = {Nakamoto - Bitcoin A Peer-to-Peer Electronic Cash System.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/IJJNYLIM/Nakamoto - Bitcoin A Peer-to-Peer Electronic Cash System.pdf:application/pdf},
}

@inproceedings{elmas_calculus_2009,
	address = {New York, NY, USA},
	series = {{POPL} '09},
	title = {A calculus of atomic actions},
	isbn = {978-1-60558-379-2},
	url = {https://doi.org/10.1145/1480881.1480885},
	doi = {10.1145/1480881.1480885},
	abstract = {We present a proof calculus and method for the static verification of assertions and procedure specifications in shared-memory concurrent programs. The key idea in our approach is to use atomicity as a proof tool and to simplify the verification of assertions by rewriting programs to consist of larger atomic actions. We propose a novel, iterative proof style in which alternating use of abstraction and reduction is exploited to compute larger atomic code blocks in a sound manner. This makes possible the verification of assertions in the transformed program by simple sequential reasoning within atomic blocks, or significantly simplified application of existing concurrent program verification techniques such as the Owicki-Gries or rely-guarantee methods. Our method facilitates a clean separation of concerns where at each phase of the proof, the user worries only about only either the sequential properties or the concurrency control mechanisms in the program. We implemented our method in a tool called QED. We demonstrate the simplicity and effectiveness of our approach on a number of benchmarks including ones with intricate concurrency protocols.},
	urldate = {2021-05-31},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
	month = jan,
	year = {2009},
	keywords = {abstraction, atomicity, concurrent programs, reduction},
	pages = {2--15},
	file = {Elmas et al. - A Calculus of Atomic Actions.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/RR8HQEEY/Elmas et al. - A Calculus of Atomic Actions.pdf:application/pdf},
}

@article{milner_calculus_1992,
	title = {A calculus of mobile processes, {I}},
	volume = {100},
	issn = {0890-5401},
	url = {https://www.sciencedirect.com/science/article/pii/0890540192900084},
	doi = {10.1016/0890-5401(92)90008-4},
	abstract = {We present the π-calculus, a calculus of communicating systems in which one can naturally express processes which have changing structure. Not only may the component agents of a system be arbitrarily linked, but a communication between neighbours may carry information which changes that linkage. The calculus is an extension of the process algebra CCS, following work by Engberg and Nielsen, who added mobility to CCS while preserving its algebraic properties. The π-calculus gains simplicity by removing all distinction between variables and constants; communication links are identified by names, and computation is represented purely as the communication of names across links. After an illustrated description of how the π-calculus generalises conventional process algebras in treating mobility, several examples exploiting mobility are given in some detail. The important examples are the encoding into the π-calculus of higher-order functions (the λ-calculus and combinatory algebra), the transmission of processes as values, and the representation of data structures as processes. The paper continues by presenting the algebraic theory of strong bisimilarity and strong equivalence, including a new notion of equivalence indexed by distinctions—i.e., assumptions of inequality among names. These theories are based upon a semantics in terms of a labeled transition system and a notion of strong bisimulation, both of which are expounded in detail in a companion paper. We also report briefly on work-in-progress based upon the corresponding notion of weak bisimulation, in which internal actions cannot be observed.},
	language = {en},
	number = {1},
	urldate = {2021-04-26},
	journal = {Information and Computation},
	author = {Milner, Robin and Parrow, Joachim and Walker, David},
	month = sep,
	year = {1992},
	pages = {1--40},
	file = {ScienceDirect Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/47I8AD9U/Milner et al. - 1992 - A calculus of mobile processes, I.pdf:application/pdf;ScienceDirect Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/IHCTPXVR/0890540192900084.html:text/html},
}

@article{milner_calculus_1992-1,
	title = {A calculus of mobile processes, {I}},
	volume = {100},
	issn = {0890-5401},
	url = {https://www.sciencedirect.com/science/article/pii/0890540192900084},
	doi = {10.1016/0890-5401(92)90008-4},
	abstract = {We present the π-calculus, a calculus of communicating systems in which one can naturally express processes which have changing structure. Not only may the component agents of a system be arbitrarily linked, but a communication between neighbours may carry information which changes that linkage. The calculus is an extension of the process algebra CCS, following work by Engberg and Nielsen, who added mobility to CCS while preserving its algebraic properties. The π-calculus gains simplicity by removing all distinction between variables and constants; communication links are identified by names, and computation is represented purely as the communication of names across links. After an illustrated description of how the π-calculus generalises conventional process algebras in treating mobility, several examples exploiting mobility are given in some detail. The important examples are the encoding into the π-calculus of higher-order functions (the λ-calculus and combinatory algebra), the transmission of processes as values, and the representation of data structures as processes. The paper continues by presenting the algebraic theory of strong bisimilarity and strong equivalence, including a new notion of equivalence indexed by distinctions—i.e., assumptions of inequality among names. These theories are based upon a semantics in terms of a labeled transition system and a notion of strong bisimulation, both of which are expounded in detail in a companion paper. We also report briefly on work-in-progress based upon the corresponding notion of weak bisimulation, in which internal actions cannot be observed.},
	language = {en},
	number = {1},
	urldate = {2021-04-26},
	journal = {Information and Computation},
	author = {Milner, Robin and Parrow, Joachim and Walker, David},
	month = sep,
	year = {1992},
	pages = {1--40},
	file = {ScienceDirect Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/J2WF6HZN/Milner et al. - 1992 - A calculus of mobile processes, I.pdf:application/pdf;ScienceDirect Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/2W6LKY48/0890540192900084.html:text/html},
}

@inproceedings{fournet_reflexive_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {The reflexive {CHAM} and the join-calculus},
	isbn = {978-0-89791-769-8},
	url = {https://doi.org/10.1145/237721.237805},
	doi = {10.1145/237721.237805},
	abstract = {By adding reflexion to the chemical machine of Berry and Boudol, we obtain a formal model of concurrency that is consistent with mobility and distribution. Our model provides the foundations of a programming language with functional and object-oriented features. It can also be seen as a process calculus, the join-calculus, which we prove equivalent to the π-calculus of Milner, Parrow and Walker.},
	urldate = {2021-04-26},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Fournet, Cédric and Gonthier, Georges},
	month = jan,
	year = {1996},
	pages = {372--385},
	file = {Fournet and Gonthier - 1996 - The reflexive CHAM and the join-calculus.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/E9BB8PDN/Fournet and Gonthier - 1996 - The reflexive CHAM and the join-calculus.pdf:application/pdf},
}

@article{lampson_crash_1979,
	title = {Crash {Recovery} in a {Distributed} {Data} {Storage} {System}},
	url = {https://www.microsoft.com/en-us/research/publication/crash-recovery-in-a-distributed-data-storage-system/},
	abstract = {An algorithm is described which guarantees reliable storage of data in a distributed system, even when different portions of the data base, stored on separate machines, are updated as part of a single transaction. The algorithm is implemented by a hierarchy of rather simple abstractions, and it works properly regardless of crashes of the client […]},
	language = {en-US},
	urldate = {2021-04-16},
	author = {Lampson, Butler and Sturgis, Howard E.},
	month = jun,
	year = {1979},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/BZAFC8GM/Lampson and Sturgis - 1979 - Crash Recovery in a Distributed Data Storage Syste.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/RR9AUPB9/crash-recovery-in-a-distributed-data-storage-system.html:text/html},
}

@article{lampson_crash_1976-1,
	title = {Crash {Recovery} in a {Distributed} {Data} {Storage} {System}},
	url = {/paper/Crash-Recovery-in-a-Distributed-Data-Storage-System-Lampson-Sturgis/6bca5c188f672eaf6e6777d1a0a7da1e1d8c6026},
	abstract = {An algorithm is described which guarantees reliable storage of data in a distributed system, even when different portions of the data base, stored on separate machines, are updated as part of a single transaction. The algorithm is implemented by a hierarchy of rather simple abstractions, and it works properly regardless of crashes of the client or servers. Some care is taken to state precisely the assumptions about the physical components of the system (storage, processors and communication).},
	language = {en},
	urldate = {2021-04-15},
	journal = {undefined},
	author = {Lampson, B. and Sturgis, Howard E.},
	year = {1976},
	file = {Lampson and Sturgis - 1976 - Crash Recovery in a Distributed Data Storage Syste.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/9GYG68XH/Lampson and Sturgis - 1976 - Crash Recovery in a Distributed Data Storage Syste.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/TMAKPA2R/6bca5c188f672eaf6e6777d1a0a7da1e1d8c6026.html:text/html},
}

@book{liu_encyclopedia_2018,
	address = {New York, NY},
	edition = {2nd ed. 2018 edition},
	title = {Encyclopedia of {Database} {Systems}},
	isbn = {978-1-4614-8264-2},
	abstract = {This revised and expanded edition of Encyclopedia of Database Systems provides easy access to crucial concepts relevant to all aspects of very large databases, data management, and database systems, including areas of current interest and research results of historical significance. This comprehensive reference is organized alphabetically and each entry presents basic terminology, concepts, methods and algorithms, key results to date, references to the literature, and cross-references to other entries. Topics for the encyclopedia―including areas of current interest as well as research results of historical significance―were selected by a distinguished international advisory board and written by world-class experts in the field. New entries that reflect recent developments and technological advances in very large databases include: big data, big data technology, cloud computing, cloud data centers, business analytics, social networks, ranking, trust management, query over encrypted data, and more. Entirely new entries include database systems, relational database systems, databases, multimedia databases, bioinformatics, workflow systems, and web data management. Encyclopedia of Database Systems, 2nd edition, is designed to meet the needs of researchers, professors, graduate and undergraduate students in computer science and engineering. Industry professionals, from database specialists to software developers, will also benefit from this valuable reference work.},
	language = {English},
	publisher = {Springer},
	editor = {Liu, Ling and Özsu, M. Tamer},
	month = nov,
	year = {2018},
	file = {Liu and Özsu - 2018 - Encyclopedia of Database Systems.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/I4T2MUQU/Liu and Özsu - 2018 - Encyclopedia of Database Systems.pdf:application/pdf},
}

@book{attiya_distributed_2004,
	address = {Hoboken, NJ},
	edition = {2nd edition},
	title = {Distributed {Computing}: {Fundamentals}, {Simulations}, and {Advanced} {Topics}},
	isbn = {978-0-471-45324-6},
	shorttitle = {Distributed {Computing}},
	abstract = {* Comprehensive introduction to the fundamental results in the mathematical foundations of distributed computing * Accompanied by supporting material, such as lecture notes and solutions for selected exercises * Each chapter ends with bibliographical notes and a set of exercises * Covers the fundamental models, issues and techniques, and features some of the more advanced topics},
	language = {English},
	publisher = {Wiley-Interscience},
	author = {Attiya, Hagit and Welch, Jennifer},
	month = mar,
	year = {2004},
	file = {(Wiley series on parallel and distributed computing) Hagit Attiya, Jennifer Welch - Distributed Computing_ Fundamentals, Simulations, and Advanced Topics-Wiley Interscience (2004).djvu:/home/pato/snap/zotero-snap/common/Zotero/storage/WYI9IA3Z/(Wiley series on parallel and distributed computing) Hagit Attiya, Jennifer Welch - Distributed Computing_ Fundamentals, Simulations, and Advanced Topics-Wiley Interscience (2004).djvu:image/vnd.djvu},
}

@article{chandra_unreliable_1996,
	title = {Unreliable failure detectors for reliable distributed systems},
	volume = {43},
	issn = {00045411},
	doi = {10.1145/226643.226647},
	language = {en},
	number = {2},
	urldate = {2019-10-04},
	journal = {Journal of the ACM},
	author = {Chandra, Tushar Deepak and Toueg, Sam},
	month = mar,
	year = {1996},
	pages = {225--267},
	file = {Chandra and Toueg - 1996 - Unreliable failure detectors for reliable distribu.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/C6WH7G4L/Chandra and Toueg - 1996 - Unreliable failure detectors for reliable distribu.pdf:application/pdf},
}

@article{gleissenthall_pretend_2019,
	title = {Pretend synchrony: synchronous verification of asynchronous distributed programs},
	shorttitle = {Pretend synchrony},
	doi = {10.1145/3290372},
	abstract = {We present pretend synchrony, a new approach to verifying distributed systems, based on the observation that while distributed programs must execute asynchronously, we can often soundly treat them as if they were synchronous when verifying their correctness. To do so, we compute a synchronization, a semantically equivalent program where all sends, receives, and message buffers, have been replaced by simple assignments, yielding a program that can be verified using Floyd-Hoare style Verification Conditions and SMT. We implement our approach as a framework for writing verified distributed programs in Go and evaluate it with four challenging case studies— the classic two-phase commit protocol, the Raft leader election protocol, single-decree Paxos protocol, and a Multi-Paxos based distributed key-value store. We find that pretend synchrony allows us to develop performant systems while making verification of functional correctness simpler by reducing manually specified invariants by a factor of 6, and faster, by reducing checking time by three orders of magnitude.},
	journal = {Proc. ACM Program. Lang.},
	author = {Gleissenthall, K. V. and Kici, Rami Gökhan and Bakst, A. and Stefan, D. and Jhala, R.},
	year = {2019},
	file = {Texte intégral:/home/pato/snap/zotero-snap/common/Zotero/storage/VCJX3G5E/Gleissenthall et al. - 2019 - Pretend synchrony synchronous verification of asy.pdf:application/pdf},
}

@article{moses_layered_2002,
	title = {A {Layered} {Analysis} of {Consensus}},
	volume = {31},
	doi = {10.1137/S0097539799364006},
	abstract = {This paper introduces a simple notion of layering as a tool for analyzingwell-behaved runs of a given model of distributed computation. Using layering, a model-independent analysis of the consensus problem is performed and then applied to provinglower bounds and impossibility results for consensus in a number of familiar and less familiar models. The proofs are simpler and more direct than existingones, and they expose a unified structure to the difficulty of reachingconsensus. In particular, the proofs for the classical synchronous and asynchronous models now follow the same outline. A new notion of connectivity amongstates in runs of a consensus protocol, called potence connectivity, is introduced. This notion is more general than previous notions of connectivity used for this purpose and plays a key role in the uniform analysis of consensus.},
	journal = {SIAM J. Comput.},
	author = {Moses, Yoram and Rajsbaum, Sergio},
	month = may,
	year = {2002},
	pages = {989--1021},
	file = {Moses et Rajsbaum - 2002 - A Layered Analysis of Consensus.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ZYW2CHBD/Moses et Rajsbaum - 2002 - A Layered Analysis of Consensus.pdf:application/pdf},
}

@book{peterson_computer_2011,
	address = {Amsterdam ; Boston},
	title = {Computer {Networks}: {A} {Systems} {Approach}},
	isbn = {978-0-12-385059-1},
	shorttitle = {Computer {Networks}},
	abstract = {Computer Networks: A Systems Approach, Fifth Edition, explores the key principles of computer networking, with examples drawn from the real world of network and protocol design. Using the Internet as the primary example, this best selling and classic textbook explains various protocols and networking technologies. The systems oriented approach encourages students to think about how individual network components fit into a larger, complex system of interactions. This book has a completely updated content with expanded coverage of the topics of utmost importance to networking professionals and students, including P2P, wireless, network security, and network applications such as e mail and the Web, IP telephony and video streaming, and peer to peer file sharing. There is now increased focus on application layer issues where innovative and exciting research and design is currently the center of attention. Other topics include network design and architecture; the ways users can connect to a network; the concepts of switching, routing, and internetworking; end to end protocols; congestion control and resource allocation; and end to end data. Each chapter includes a problem statement, which introduces issues to be examined; shaded sidebars that elaborate on a topic or introduce a related advanced topic; What’s Next? discussions that deal with emerging issues in research, the commercial world, or society; and exercises. This book is written for graduate or upper division undergraduate classes in computer networking. It will also be useful for industry professionals retraining for network related assignments, as well as for network practitioners seeking to understand the workings of network protocols and the big picture of networking. Completely updated content with expanded coverage of the topics of utmost importance to networking professionals and students, including P2P, wireless, security, and applicationsIncreased focus on application layer issues where innovative and exciting research and design is currently the center of attentionFree downloadable network simulation software and lab experiments manual available},
	language = {Inglés},
	author = {Peterson, Larry L. and Davie, Bruce S.},
	month = mar,
	year = {2011},
	file = {Peterson et Davie - Computer Networks A Systems Approach.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/8PA7N8VR/Peterson et Davie - Computer Networks A Systems Approach.pdf:application/pdf},
}

@article{hawblitzel_automated_2015,
	title = {Automated and modular refinement reasoning for concurrent programs},
	url = {https://www.microsoft.com/en-us/research/publication/automated-and-modular-refinement-reasoning-for-concurrent-programs/},
	abstract = {We present CIVL, a language and verifier for concurrent programs based on automated and modular refinement reasoning. CIVL supports reasoning about a concurrent program at many levels of abstraction. Atomic actions in a high-level description are refined to fine-grain and optimized lower-level implementations. Modular specifications and proof annotations, such as location invariants and procedure pre- […]},
	language = {en-US},
	urldate = {2021-02-25},
	author = {Hawblitzel, Chris and Qadeer, Shaz and Tasiran, Serdar},
	month = feb,
	year = {2015},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/KJHEUCC2/Hawblitzel et al. - 2015 - Automated and modular refinement reasoning for con.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/WFA77K4E/automated-and-modular-refinement-reasoning-for-concurrent-programs.html:text/html},
}

@article{lamport_paxos_2001,
	title = {Paxos {Made} {Simple}},
	url = {https://www.microsoft.com/en-us/research/publication/paxos-made-simple/},
	abstract = {At the PODC 2001 conference, I got tired of everyone saying how difficult it was to understand the Paxos algorithm, published in [122]. Although people got so hung up in the pseudo-Greek names that they found the paper hard to understand, the algorithm itself is very simple. So, I cornered a couple of people at […]},
	language = {en-US},
	urldate = {2021-02-23},
	journal = {ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001)},
	author = {Lamport, Leslie},
	month = dec,
	year = {2001},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/99ZPR9SW/Lamport - 2016 - Paxos Made Simple.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/KFE2LPCS/paxos-made-simple.html:text/html},
}

@article{leino_this_2016,
	title = {This is {Boogie} 2},
	url = {https://www.microsoft.com/en-us/research/publication/this-is-boogie-2-2/},
	abstract = {Boogie is an intermediate verification language, designed to make the prescription of verification conditions natural and convenient. It serves as a common intermediate representation for static program verifiers of various source languages, and it abstracts over the interfaces to various theorem provers. Boogie can also be used as a shared input and output format for […]},
	language = {en-US},
	urldate = {2021-02-10},
	author = {Leino, K. Rustan M.},
	month = dec,
	year = {2016},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/WT4DZ2PN/Leino - 2016 - This is Boogie 2.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/5FR6XZSE/this-is-boogie-2-2.html:text/html},
}

@article{dragoi_testing_2020,
	title = {Testing consensus implementations using communication closure},
	volume = {4},
	issn = {2475-1421, 2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3428278},
	doi = {10.1145/3428278},
	abstract = {CEZARA DRĂGOI, INRIA, France and Informal Systems, France CONSTANTIN ENEA, Université de Paris, IRIF, CNRS, France BURCU KULAHCIOGLU OZKAN, MPI-SWS, Germany RUPAK MAJUMDAR, MPI-SWS, Germany FILIP NIKSIC, University of Pennsylvania, USA Large scale production distributed systems are difficult to design and test. Correctness must be ensured when processes run asynchronously, at arbitrary rates relative to each other, and in the presence of failures, e.g., process crashes or message losses. These conditions create a huge space of executions that is difficult to explore in a principled way. Current testing techniques focus on systematic or randomized exploration of all executions of an implementation while treating the implemented algorithms as black boxes. On the other hand, proofs of correctness of many of the underlying algorithms often exploit semantic properties that reduce reasoning about correctness to a subset of behaviors. For example, the communication-closure property, used in many proofs of distributed consensus algorithms, shows that every asynchronous execution of the algorithm is equivalent to a lossy synchronous execution, thus reducing the burden of proof to only that subset. In a lossy synchronous execution, processes execute in lock-step rounds, and messages are either received in the same round or lost foreverÐsuch executions form a small subset of all asynchronous ones. We formulate the communication-closure hypothesis, which states that bugs in implementations of distributed consensus algorithms will already manifest in lossy synchronous executions and present a testing algorithm based on this hypothesis. We prioritize the search space based on a bound on the number of failures in the execution and the rate at which these failures are recovered. We show that a random testing algorithm based on sampling lossy synchronous executions can empirically find a number of bugsÐincluding previously unknown onesÐin production distributed systems such as Zookeeper, Cassandra, and Ratis, and also produce more understandable bug traces. CCS Concepts: · Software and its engineering → Software testing and debugging; · Theory of computation → Distributed computing models.},
	language = {en},
	number = {OOPSLA},
	urldate = {2021-02-02},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Drăgoi, Cezara and Enea, Constantin and Ozkan, Burcu Kulahcioglu and Majumdar, Rupak and Niksic, Filip},
	month = nov,
	year = {2020},
	pages = {1--29},
	file = {Drăgoi et al. - 2020 - Testing consensus implementations using communicat.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/7BMTZXWW/Drăgoi et al. - 2020 - Testing consensus implementations using communicat.pdf:application/pdf},
}

@inproceedings{demers_epidemic_1987,
	address = {New York, NY, USA},
	series = {{PODC} '87},
	title = {Epidemic algorithms for replicated database maintenance},
	isbn = {978-0-89791-239-6},
	url = {https://doi.org/10.1145/41840.41841},
	doi = {10.1145/41840.41841},
	urldate = {2021-01-29},
	booktitle = {Proceedings of the sixth annual {ACM} {Symposium} on {Principles} of distributed computing},
	publisher = {Association for Computing Machinery},
	author = {Demers, Alan and Greene, Dan and Hauser, Carl and Irish, Wes and Larson, John and Shenker, Scott and Sturgis, Howard and Swinehart, Dan and Terry, Doug},
	month = dec,
	year = {1987},
	pages = {1--12},
	file = {Dan et al. - EPIDEMIC ALGORITHMS FOR REPLICA’TED DATABASE MAINT.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/QHDJLTS5/Dan et al. - EPIDEMIC ALGORITHMS FOR REPLICA’TED DATABASE MAINT.pdf:application/pdf},
}

@inproceedings{rutti_generic_2010,
	title = {Generic construction of consensus algorithms for benign and {Byzantine} faults},
	doi = {10.1109/DSN.2010.5544299},
	abstract = {The paper proposes a generic consensus algorithm that highlights the basic and common features of known consensus algorithms. The parameters of the generic algorithm encapsulate the core differences between various consensus algorithms, including leader-based and leader-free algorithms, addressing benign faults, authenticated Byzantine faults and Byzantine faults. This leads to the identification of three classes of consensus algorithms. With the proposed classification, Paxos and PBFT indeed belong to the same class, while FaB Paxos belongs to a different class. Interestingly, the classification allowed us to identify a new Byzantine consensus algorithm that requires n {\textgreater} 4b, where b is the maximum number of Byzantine processes.},
	booktitle = {2010 {IEEE}/{IFIP} {International} {Conference} on {Dependable} {Systems} {Networks} ({DSN})},
	author = {Rütti, O. and Milosevic, Z. and Schiper, A.},
	month = jun,
	year = {2010},
	note = {ISSN: 2158-3927},
	keywords = {Fault tolerance, benign fault, byzantine fault, Detectors, distributed algorithms, Distributed computing, Fault detection, Fault diagnosis, fault tolerant computing, generic consensus algorithm, Lead, leader based algorithm, leader free algorithm, Reactive power},
	pages = {343--352},
	file = {IEEE Xplore Abstract Record:/home/pato/snap/zotero-snap/common/Zotero/storage/MTM7XLE5/5544299.html:text/html;Version soumise:/home/pato/snap/zotero-snap/common/Zotero/storage/NTP6IQFD/Rütti et al. - 2010 - Generic construction of consensus algorithms for b.pdf:application/pdf},
}

@book{ullman_principles_1988,
	address = {Rockville, Md},
	title = {Principles of {Database} and {Knowledge}-{Base} {Systems}, {Vol}. 1 ({Principles} of {Computer} {Science} {Series}) by {Ullman}, {Jeffrey} {D} (1988) {Hardcover}},
	isbn = {978-0-88175-188-8},
	abstract = {1. Databases, Object Bases, and Knowledge Bases 2. Data Models for Database Systems 3. Logic as a Data Model 4. Relational Query Languages 5. Object-Oriented Database Languages 6. Physical Data Organization 7. Design Theory for Relational Databases 8. Protecting the Database Against Misuse 9. Transaction Management 10. Distributed Database Management},
	language = {English},
	publisher = {Computer Science Press},
	author = {Ullman, Jeffrey D.},
	month = jan,
	year = {1988},
	file = {[Contributions to Management Science] Jeffrey D Ullman - Principles of Database and Knowledge-Base Systems Vol. 1(1988, Computer Science Press) - libgen.lc.djvu:/home/pato/snap/zotero-snap/common/Zotero/storage/8CS4X622/[Contributions to Management Science] Jeffrey D Ullman - Principles of Database and Knowledge-Base Systems Vol. 1(1988, Computer Science Press) - libgen.lc.djvu:image/vnd.djvu},
}

@book{milewski_bartosz_category_2019,
	title = {Category {Theory} for {Programmers}},
	isbn = {978-0-464-24387-8},
	url = {http://www.blurb.com/b/9621951-category-theory-for-programmers-new-edition-hardco},
	abstract = {Find Category Theory for Programmers (New Edition, Hardcover) by Bartosz Milewski at Blurb Books. Category Theory is one of the most abstract branches of mathema...},
	language = {en},
	urldate = {2020-11-29},
	author = {Milewski, Bartosz},
	month = aug,
	year = {2019},
	file = {2019 - Category Theory for Programmers (New Edition, Hard.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/NMDLGRNZ/2019 - Category Theory for Programmers (New Edition, Hard.pdf:application/pdf;Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/EDDRTV26/9621951-category-theory-for-programmers-new-edition-hardco.html:text/html},
}

@book{artin_algebra_2010,
	address = {Boston, MA},
	edition = {2nd edition},
	title = {Algebra},
	isbn = {978-0-13-241377-0},
	abstract = {Algebra, Second Edition, by Michael Artin, provides comprehensive coverage at the level of an honors-undergraduate or introductory-graduate course. The second edition of this classic text incorporates twenty years of feedback plus the author’s own teaching experience. This book discusses concrete topics of algebra in greater detail than others, preparing readers for the more abstract concepts; linear algebra is tightly integrated throughout.},
	language = {English},
	publisher = {Pearson},
	author = {Artin, Michael},
	month = aug,
	year = {2010},
	file = {Artin - 2010 - Algebra.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/IE8C97L5/Artin - 2010 - Algebra.pdf:application/pdf},
}

@book{dummit_abstract_2003,
	address = {Hoboken, NJ},
	edition = {3rd edition},
	title = {Abstract {Algebra}, 3rd {Edition}},
	isbn = {978-0-471-43334-7},
	abstract = {This revision of Dummit and Foote's widely acclaimed introduction to abstract algebra helps students experience the power and beauty that develops from the rich interplay between different areas of mathematics.   The book carefully develops the theory of different algebraic structures, beginning from basic definitions to some in-depth results, using numerous examples and exercises to aid the student's understanding. With this approach, students gain an appreciation for how mathematical structures and their interplay lead to powerful results and insights in a number of different settings.  The text is designed for a full-year introduction to abstract algebra at the advanced undergraduate or graduate level, but contains substantially more material than would normally be covered in one year. Portions of the book may also be used for various one-semester topics courses in advanced algebra, each of which would provide a solid background for a follow-up course delving more deeply into one of many possible areas: algebraic number theory, algebraic topology, algebraic geometry, representation theory, Lie groups, etc.},
	language = {English},
	publisher = {Wiley},
	author = {Dummit, David S. and Foote, Richard M.},
	month = jul,
	year = {2003},
	file = {David S. Dummit, Richard M. Foote - Abstract Algebra, 3rd Edition -Wiley (2003).pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/HTV9CI87/David S. Dummit, Richard M. Foote - Abstract Algebra, 3rd Edition -Wiley (2003).pdf:application/pdf},
}

@book{hodges_model_1993,
	address = {Cambridge},
	series = {Encyclopedia of {Mathematics} and its {Applications}},
	title = {Model {Theory}},
	isbn = {978-0-521-30442-9},
	url = {https://www.cambridge.org/core/books/model-theory/BB219FC37218A7CADE5906625E6B4BC1},
	abstract = {This is an up-to-date and integrated introduction to model theory, designed to be used for graduate courses (for students who are familiar with first-order logic), and as a reference for more experienced logicians and mathematicians. Model theory is concerned with the notions of definition, interpretation and structure in a very general setting, and is applied to a wide variety of other areas such as set theory, geometry, algebra (in particular group theory), and computer science (e.g. logic programming and specification). Professor Hodges emphasises definability and methods of construction, and introduces the reader to advanced topics such as stability. He also provides the reader with much historical information and a full bibliography, enhancing the book's use as a reference.},
	urldate = {2020-11-06},
	publisher = {Cambridge University Press},
	author = {Hodges, Wilfrid},
	year = {1993},
	doi = {10.1017/CBO9780511551574},
	file = {Wilfrid Hodges - Model theory.djvu:/home/pato/snap/zotero-snap/common/Zotero/storage/K33YRNIV/Wilfrid Hodges - Model theory.djvu:image/vnd.djvu},
}

@misc{noauthor_static_nodate,
	title = {Static {Program} {Analysis}},
	url = {https://www.cs.au.dk/~amoeller/spa/},
	urldate = {2020-10-15},
	file = {spa.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/V34ZB9R3/spa.pdf:application/pdf;Static Program Analysis:/home/pato/snap/zotero-snap/common/Zotero/storage/WNM7I7SD/spa.html:text/html},
}

@article{rice_classes_1954,
	title = {Classes of {Recursively} {Enumerable} {Sets} and {Their} {Decision} {Problems}},
	volume = {19},
	doi = {10.2307/2268870},
	number = {2},
	journal = {Journal of Symbolic Logic},
	author = {Rice, H. G.},
	year = {1954},
	note = {Publisher: Association for Symbolic Logic},
	pages = {121--122},
	file = {S0002-9947-1953-0053041-6.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/CKD7E49U/S0002-9947-1953-0053041-6.pdf:application/pdf},
}

@book{nielson_principles_1999,
	address = {Berlin Heidelberg},
	title = {Principles of {Program} {Analysis}},
	isbn = {978-3-540-65410-0},
	url = {https://www.springer.com/gp/book/9783540654100},
	abstract = {Program analysis concerns static techniques for computing reliable approximate information about the dynamic behaviour of programs. Applications include compilers (for code improvement), software validation (for detecting errors in algorithms or breaches of security) and transformations between data representation (for solving problems such as the Y2K problem). This book is unique in giving an overview of the four major approaches to program analysis: data flow analysis, constraint based analysis, abstract interpretation, and type and effect systems. The presentation demonstrates the extensive similarities between the approaches; this will aid the reader in choosing the right approach and in enhancing it with insights from the other approaches. The book covers basic semantic properties as well as more advanced algorithmic techniques. The book is aimed at M.Sc. and Ph.D. students but will be valuable also for experienced researchers and professionals.},
	language = {en},
	urldate = {2020-10-13},
	publisher = {Springer-Verlag},
	author = {Nielson, Flemming and Nielson, Hanne R. and Hankin, Chris},
	year = {1999},
	doi = {10.1007/978-3-662-03811-6},
	file = {Flemming Nielson, Hanne R. Nielson, Chris Hankin - Principles of Program Analysis-Springer (2005).pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/RC8YMKCG/Flemming Nielson, Hanne R. Nielson, Chris Hankin - Principles of Program Analysis-Springer (2005).pdf:application/pdf},
}

@book{nielson_principles_1999-1,
	address = {Berlin ; New York},
	edition = {Corrected Edition},
	title = {Principles of {Program} {Analysis}},
	isbn = {978-3-540-65410-0},
	abstract = {Program analysis utilizes static techniques for computing reliable information about the dynamic behavior of programs. Applications include compilers (for code improvement), software validation (for detecting errors) and transformations between data representation (for solving problems such as Y2K). This book is unique in providing an overview of the four major approaches to program analysis: data flow analysis, constraint-based analysis, abstract interpretation, and type and effect systems. The presentation illustrates the extensive similarities between the approaches, helping readers to choose the best one to utilize.},
	language = {English},
	publisher = {Springer},
	author = {Nielson, Flemming and Nielson, Hanne R. and Hankin, Chris},
	month = oct,
	year = {1999},
}

@book{noauthor_principles_nodate,
	title = {Principles of {Program} {Analysis}},
	url = {http://www.imm.dtu.dk/~hrni/PPA/ppa.html},
	urldate = {2020-10-13},
	file = {Principles of Program Analysis.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/SM4LLHP8/Principles of Program Analysis.pdf:application/pdf},
}

@book{bradley_calculus_2007,
	address = {Berlin},
	title = {Calculus of computation: decision procedures with applications to verification},
	isbn = {978-3-540-74112-1},
	shorttitle = {Calculus of computation},
	language = {en},
	publisher = {Springer},
	author = {Bradley, Aaron R. and Manna, Zohar},
	year = {2007},
	note = {OCLC: ocn190764844},
	keywords = {Computer logic, Computer programs, Verification},
	file = {Bradley et Manna - 2007 - Calculus of computation decision procedures with .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/R3URNFKG/Bradley et Manna - 2007 - Calculus of computation decision procedures with .pdf:application/pdf},
}

@incollection{goos_verification_2003,
	address = {Berlin, Heidelberg},
	title = {Verification by {Abstract} {Interpretation}},
	volume = {2772},
	isbn = {978-3-540-21002-3 978-3-540-39910-0},
	url = {http://link.springer.com/10.1007/978-3-540-39910-0_11},
	abstract = {Abstract interpretation theory formalizes the idea of abstraction of mathematical structures, in particular those involved in the speciﬁcation of properties and proof methods of computer systems. Veriﬁcation by abstract interpretation is illustrated on the particular cases of predicate abstraction, which is revisited to handle inﬁnitary abstractions, and on the new parametric predicate abstraction.},
	language = {en},
	urldate = {2020-10-06},
	booktitle = {Verification: {Theory} and {Practice}},
	publisher = {Springer Berlin Heidelberg},
	author = {Cousot, Patrick},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Dershowitz, Nachum},
	year = {2003},
	doi = {10.1007/978-3-540-39910-0_11},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {243--268},
	file = {Cousot - 2003 - Verification by Abstract Interpretation.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/GKBK26JM/Cousot - 2003 - Verification by Abstract Interpretation.pdf:application/pdf},
}

@article{king_symbolic_1976,
	title = {Symbolic execution and program testing},
	volume = {19},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=360248.360252},
	doi = {10.1145/360248.360252},
	number = {7},
	urldate = {2020-09-01},
	journal = {Communications of the ACM},
	author = {King, James C.},
	month = jul,
	year = {1976},
	pages = {385--394},
	file = {king76symbolicexecution.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/KE4NHAE9/king76symbolicexecution.pdf:application/pdf},
}

@article{milner_calculus_1992-2,
	title = {A calculus of mobile processes, {Part} 2},
	volume = {100},
	issn = {0890-5401},
	url = {http://www.sciencedirect.com/science/article/pii/0890540192900095},
	doi = {10.1016/0890-5401(92)90009-5},
	abstract = {This is the second of two papers in which we present the π-calculus, a calculus of mobile processes. We provide a detailed presentation of some of the theory of the calculus developed to date, and in particular we establish most of the results stated in the companion paper.},
	number = {1},
	urldate = {2019-05-05},
	journal = {Information and Computation},
	author = {Milner, Robin and Parrow, Joachim and Walker, David},
	month = sep,
	year = {1992},
	pages = {41--77},
	file = {ScienceDirect Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/WHSG9TW3/Milner et al. - 1992 - A calculus of mobile processes, II.pdf:application/pdf;ScienceDirect Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/IUTSPPY5/0890540192900095.html:text/html},
}

@inproceedings{walker_calculus_1989,
	title = {A {Calculus} of {Mobile} {Processes}, {Part} 1},
	abstract = {We present the -calculus, a calculus of communicating systems in which one can naturally express processes which have changing structure. Not only may the component agents of a system be arbitrarily linked, but a communication between neighbours may carry information which changes that linkage. The calculus is an extension of the process algebra CCS, following work by Engberg and Nielsen who added mobility to CCS while preserving its algebraic properties. The -calculus gains simplicity by removing all distinction between variables and constants; communication links are identi ed by names, and computation is represented purely as the communication of names across links. After an illustrated description of how the -calculus generalises conventional process algebras in treating mobility, several examples exploiting mobility are given in some detail. The important examples are the encoding into the calculus of higher-order functions (the -calculus and combinatory algebra), the transmission of processes as values, and the representation of data structures as processes. The paper continues by presenting the algebraic theory of strong bisimilarity and strong equivalence, including a new notion of equivalence indexed by distinctions \{\vphantom{\}} i.e. assumptions of inequality among names. These theories are based upon a semantics in terms of a labelled transition system and a notion of strong bisimulation, both of which are expounded in detail in a companion paper. We also report brie y on work-in-progress based upon the corresponding notion of weak bisimulation, in which internal actions cannot be observed. Special symbols: Since this copy is mathematically type-set, only a few of the less obvious symbols are listed below. Greek letters = : . ' . ' {\textless} {\textgreater} = Various relation symbols 0 Boldface zero ; Empty set S S0 S1 S2 K K0 K1 I I0 I1 Boldface symbols for Combinators s0 : : : t : : : cons Various constant names A C0 : : : SGE Boldface names of axioms etc [[ ]] Double square brackets},
	author = {Walker, David},
	year = {1989},
	keywords = {Bisimulation, Calculi, Calculus of communicating systems, Cobham's thesis, Combinatory logic, Computation, Data structure, Fixed-point combinator, Formal system, Graph reduction, Higher-order function, Index, Jervell-Lange Nielsen Syndrome, Linear algebra, Linkage (software), Name, Naruto Shippuden: Clash of Ninja Revolution 3, Oracle Grid Engine, Parallel computing, Process calculus, Rule (guideline), Social inequality, Theory, Transition system, Turing completeness},
	file = {Full Text PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/LPULC2A2/Walker - 1989 - A Calculus of Mobile Processes, Part I.pdf:application/pdf},
}

@article{jacobs_verifast_nodate,
	title = {The {VeriFast} {Program} {Veriﬁer}},
	abstract = {This note describes a separation-logic-based approach for the speciﬁcation and veriﬁcation of safety properties of pointer-manipulating imperative programs. We describe the approach for the C language. The safety properties to be veriﬁed are speciﬁed as annotations in the source code, in the form of function preconditions and postconditions expressed as separation logic assertions. To enable rich speciﬁcations, the user may include additional annotations that deﬁne inductive datatypes, primitive recursive pure functions over these datatypes, and abstract predicates (i.e. named, parameterized assertions). A restricted form of existential quantiﬁcation is supported in assertions in the form of pattern matching.},
	language = {en},
	author = {Jacobs, Bart and Piessens, Frank},
	pages = {5},
	file = {Jacobs et Piessens - The VeriFast Program Veriﬁer.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VSPQT6GQ/Jacobs et Piessens - The VeriFast Program Veriﬁer.pdf:application/pdf},
}

@inproceedings{abadi_existence_1988,
	title = {The existence of refinement mappings},
	doi = {10.1109/LICS.1988.5115},
	abstract = {Refinement mappings are used to prove that a lower-level specification correctly implements a higher-level one. The authors consider specifications consisting of a state machine (which may be infinite-state) that specifies safety requirements and an arbitrary supplementary property that specifies liveness requirements. A refinement mapping from a lower-level specification S/sub 1/ to higher-level one S/sub 2/ is a mapping from S/sub 1/'s state space to S/sub 2/'s state space that maps steps of S/sub 1/'s state machine steps to steps of S/sub 2/'s state machine and maps behaviors allowed by S/sub 1/ to behaviors allowed by S/sub 2/. It is shown that under reasonable assumptions about the specifications, if S/sub 1/ implements S/sub 2/, then by adding auxiliary variables to S/sub 1/ one can guarantee the existence of a refinement mapping. This provides a completeness result for a practical hierarchical specification method.{\textless}{\textgreater}},
	booktitle = {[1988] {Proceedings}. {Third} {Annual} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Abadi, M. and Lamport, L.},
	month = jul,
	year = {1988},
	keywords = {state machine, automata theory, Circuits, existence, hierarchical specification method, liveness requirements, lower-level specification, refinement mappings, Safety, safety requirements, State-space methods, Writing},
	pages = {165--175},
	file = {Abadi et Lamport - 1988 - The existence of refinement mappings.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/NG9K6PTL/Abadi et Lamport - 1988 - The existence of refinement mappings.pdf:application/pdf},
}

@article{dolev_minimal_1987,
	title = {On the {Minimal} {Synchronism} {Needed} for {Distributed} {Consensus}},
	abstract = {Reaching agreement is a primitive of distributed computing. Whereas this poses no problem in an ideal, failure-free environment, it imposes certain constraints on the capabilities of an actual system: A system is viable only if it permits the existence of consensus protocols tolerant to some number of failures. Fischer et al. have shown that in a completely asynchronous model, even one failure cannot be tolerated. In this paper their work is extended: Several critical system parameters, including various synchrony conditions, are identified and how varying these affects the number of faults that can be tolerated is examined. The proofs expose general heuristic principles that explain why consensus is possible in certain models but not possible in others.},
	language = {en},
	author = {Dolev, Danny and Dwork, Cynthia},
	year = {1987},
	pages = {21},
	file = {Dolev and Dwork - On the Minimal Synchronism Needed for Distributed .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VVSRBR69/Dolev and Dwork - On the Minimal Synchronism Needed for Distributed .pdf:application/pdf;Dolev and Dwork - On the Minimal Synchronism Needed for Distributed .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/X9UD9G3B/Dolev and Dwork - On the Minimal Synchronism Needed for Distributed .pdf:application/pdf},
}

@article{clarke_automatic_1986,
	title = {Automatic verification of finite-state concurrent systems using temporal logic specifications},
	volume = {8},
	issn = {0164-0925, 1558-4593},
	url = {http://dl.acm.org/doi/10.1145/5397.5399},
	doi = {10.1145/5397.5399},
	language = {en},
	number = {2},
	urldate = {2020-07-24},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Clarke, E. M. and Emerson, E. A. and Sistla, A. P.},
	month = apr,
	year = {1986},
	pages = {244--263},
	file = {Clarke et al. - 1986 - Automatic verification of finite-state concurrent .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/JH3MZALZ/Clarke et al. - 1986 - Automatic verification of finite-state concurrent .pdf:application/pdf},
}

@incollection{goos_branching_2001,
	address = {Berlin, Heidelberg},
	title = {Branching vs. {Linear} {Time}: {Final} {Showdown}},
	volume = {2031},
	isbn = {978-3-540-41865-8 978-3-540-45319-2},
	shorttitle = {Branching vs. {Linear} {Time}},
	url = {http://link.springer.com/10.1007/3-540-45319-9_1},
	abstract = {The discussion of the relative merits of linear- versus branching-time frameworks goes back to early 1980s. One of the beliefs dominating this discussion has been that “while specifying is easier in LTL (linear-temporal logic), veriﬁcation is easier for CTL (branching-temporal logic)”. Indeed, the restricted syntax of CTL limits its expressive power and many important behaviors (e.g., strong fairness) can not be speciﬁed in CTL. On the other hand, while model checking for CTL can be done in time that is linear in the size of the speciﬁcation, it takes time that is exponential in the speciﬁcation for LTL. Because of these arguments, and for historical reasons, the dominant temporal speciﬁcation language in industrial use is CTL.},
	language = {en},
	urldate = {2020-07-24},
	booktitle = {Tools and {Algorithms} for the {Construction} and {Analysis} of {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Vardi, Moshe Y.},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Margaria, Tiziana and Yi, Wang},
	year = {2001},
	doi = {10.1007/3-540-45319-9_1},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {1--22},
	file = {Vardi - 2001 - Branching vs. Linear Time Final Showdown.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/ADMHZBJB/Vardi - 2001 - Branching vs. Linear Time Final Showdown.pdf:application/pdf},
}

@article{finkbeiner_linear-hyper-branching_2014,
	title = {The linear-hyper-branching spectrum of temporal logics},
	volume = {56},
	issn = {1611-2776, 2196-7032},
	url = {https://www.degruyter.com/view/j/itit.2014.56.issue-6/itit-2014-1067/itit-2014-1067.xml},
	doi = {10.1515/itit-2014-1067},
	abstract = {The family of temporal logics has recently been extended with logics for the specification of hyperproperties, such as noninterference or observational determinism. Hyperproperties relate multiple computation paths of a system by requiring that they satisfy a certain relationship, such as an identical valuation of the low-security outputs. Unlike classic temporal logics like LTL or CTL*, which refer to one computation path at a time, temporal logics for hyperproperties like HyperLTL and HyperCTL* can express such relationships by explicitly quantifying over multiple computation paths simultaneously. In this paper, we study the extended spectrum of temporal logics by relating the new logics to the linear-branching spectrum of process equivalences.},
	language = {en},
	number = {6},
	urldate = {2020-07-24},
	journal = {it - Information Technology},
	author = {Finkbeiner, Bernd and Rabe, Markus N.},
	month = jan,
	year = {2014},
	file = {Finkbeiner et Rabe - 2014 - The linear-hyper-branching spectrum of temporal lo.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/VRV9IFRQ/Finkbeiner et Rabe - 2014 - The linear-hyper-branching spectrum of temporal lo.pdf:application/pdf},
}

@inproceedings{pnueli_temporal_1977,
	address = {Providence, RI, USA},
	title = {The temporal logic of programs},
	url = {http://ieeexplore.ieee.org/document/4567924/},
	doi = {10.1109/SFCS.1977.32},
	abstract = {A unified approach to program verification is suggested, which applies to both sequential and parallel programs. The main proof method suggested is that of temporal reasoning in which the time dependence of events is the basic concept. Two forma 1 systems are presented for providing a basis for temporal reasoning. One forms a formalization of the method of intermittent assertions, while the other is an adaptation of the tense logic system Kb , and is particularly suitable for reasoning about concurrent programs.},
	language = {en},
	urldate = {2020-07-23},
	booktitle = {18th {Annual} {Symposium} on {Foundations} of {Computer} {Science} (sfcs 1977)},
	publisher = {IEEE},
	author = {Pnueli, Amir},
	month = sep,
	year = {1977},
	pages = {46--57},
	file = {Pnueli - 1977 - The temporal logic of programs.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/M3Y3LLWX/Pnueli - 1977 - The temporal logic of programs.pdf:application/pdf},
}

@misc{noauthor_lecture_nodate,
	title = {Lecture notes for {NATO} summer school on verification of digital and hybrid systems},
	file = {compositional.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/9L7EZWRY/compositional.ps:application/postscript;intro.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/G9AKZJX7/intro.ps:application/postscript;modelchecking.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/2JWKEIXD/modelchecking.ps:application/postscript;modelchecking2.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/M5F4MKI8/modelchecking2.ps:application/postscript;symbolic.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/K2Q3F2TH/symbolic.ps:application/postscript;symmetry.ps:/home/pato/snap/zotero-snap/common/Zotero/storage/X56BUNB6/symmetry.ps:application/postscript},
}

@article{tsuchiya_verification_2011,
	title = {Verification of consensus algorithms using satisfiability solving},
	volume = {23},
	issn = {0178-2770, 1432-0452},
	url = {http://link.springer.com/10.1007/s00446-010-0123-3},
	doi = {10.1007/s00446-010-0123-3},
	abstract = {Consensus is at the heart of fault-tolerant distributed computing systems. Much research has been devoted to developing algorithms for this particular problem. This paper presents a semi-automatic veriﬁcation approach for asynchronous consensus algorithms, aiming at facilitating their development. Our approach uses model checking, a widely practiced veriﬁcation method based on state traversal. The challenge here is that the state space of these algorithms is huge, often inﬁnite, thus making model checking infeasible. The proposed approach addresses this difﬁculty by reducing the veriﬁcation problem to small model checking problems that involve only single phases of algorithm execution. Because a phase consists of a small, ﬁnite number of rounds, bounded model checking, a technique using satisﬁability solving, can be effectively used to solve these problems. The proposed approach allows us to model check several consensus algorithms up to around 10 processes.},
	language = {en},
	number = {5-6},
	urldate = {2020-07-22},
	journal = {Distributed Computing},
	author = {Tsuchiya, Tatsuhiro and Schiper, André},
	month = apr,
	year = {2011},
	pages = {341--358},
	file = {Tsuchiya et Schiper - 2011 - Verification of consensus algorithms using satisfi.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/9MBEM8FK/Tsuchiya et Schiper - 2011 - Verification of consensus algorithms using satisfi.pdf:application/pdf},
}

@incollection{dillig_parameterized_2018,
	address = {Cham},
	title = {Parameterized {Model} {Checking} of {Synchronous} {Distributed} {Algorithms} by {Abstraction}},
	volume = {10747},
	isbn = {978-3-319-73720-1 978-3-319-73721-8},
	url = {http://link.springer.com/10.1007/978-3-319-73721-8_1},
	abstract = {Parameterized veriﬁcation of fault-tolerant distributed algorithms has recently gained more and more attention. Most of the existing work considers asynchronous distributed systems (interleaving semantics). However, there exists a considerable distributed computing literature on synchronous fault-tolerant distributed algorithms: conceptually, all processes proceed in lock-step rounds, that is, synchronized steps of all (correct) processes bring the system into the next state.},
	language = {en},
	urldate = {2020-07-22},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}},
	publisher = {Springer International Publishing},
	author = {Aminof, Benjamin and Rubin, Sasha and Stoilkovska, Ilina and Widder, Josef and Zuleger, Florian},
	editor = {Dillig, Isil and Palsberg, Jens},
	year = {2018},
	doi = {10.1007/978-3-319-73721-8_1},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {1--24},
	file = {Aminof et al. - 2018 - Parameterized Model Checking of Synchronous Distri.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/I9B2NMC5/Aminof et al. - 2018 - Parameterized Model Checking of Synchronous Distri.pdf:application/pdf},
}

@article{suzuki_proving_1988,
	title = {Proving {Properties} of a {Ring} of {Finite}-state {Machines}},
	author = {Suzuki, I},
	year = {1988},
	file = {Proving Properties of a Ring of Finite-state Machines.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/3UE5CP2T/Proving Properties of a Ring of Finite-state Machines.pdf:application/pdf},
}

@article{apt_limits_1986,
	title = {Limits for automatic verification of finite-state concurrent systems},
	volume = {22},
	issn = {00200190},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0020019086900712},
	doi = {10.1016/0020-0190(86)90071-2},
	language = {en},
	number = {6},
	urldate = {2020-07-22},
	journal = {Information Processing Letters},
	author = {Apt, Krzysztof R. and Kozen, Dexter C.},
	month = may,
	year = {1986},
	pages = {307--309},
	file = {Apt et Kozen - 1986 - Limits for automatic verification of finite-state .pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/9XIAPS6M/Apt et Kozen - 1986 - Limits for automatic verification of finite-state .pdf:application/pdf},
}

@inproceedings{konnov_short_2017,
	address = {Paris, France},
	title = {A short counterexample property for safety and liveness verification of fault-tolerant distributed algorithms},
	isbn = {978-1-4503-4660-3},
	url = {http://dl.acm.org/citation.cfm?doid=3009837.3009860},
	doi = {10.1145/3009837.3009860},
	abstract = {Distributed algorithms have many mission-critical applications ranging from embedded systems and replicated databases to cloud computing. Due to asynchronous communication, process faults, or network failures, these algorithms are difﬁcult to design and verify. Many algorithms achieve fault tolerance by using threshold guards that, for instance, ensure that a process waits until it has received an acknowledgment from a majority of its peers. Consequently, domain-speciﬁc languages for fault-tolerant distributed systems offer language support for threshold guards. We introduce an automated method for model checking of safety and liveness of threshold-guarded distributed algorithms in systems where the number of processes and the fraction of faulty processes are parameters. Our method is based on a short counterexample property: if a distributed algorithm violates a temporal speciﬁcation (in a fragment of LTL), then there is a counterexample whose length is bounded and independent of the parameters. We prove this property by (i) characterizing executions depending on the structure of the temporal formula, and (ii) using commutativity of transitions to accelerate and shorten executions. We extended the ByMC toolset (Byzantine Model Checker) with our technique, and veriﬁed liveness and safety of 10 prominent fault-tolerant distributed algorithms, most of which were out of reach for existing techniques.},
	language = {en},
	urldate = {2020-07-22},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages} - {POPL} 2017},
	publisher = {ACM Press},
	author = {Konnov, Igor and Lazić, Marijana and Veith, Helmut and Widder, Josef},
	year = {2017},
	pages = {719--734},
	file = {Konnov et al. - 2017 - A short counterexample property for safety and liv.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/YUHGNFQP/Konnov et al. - 2017 - A short counterexample property for safety and liv.pdf:application/pdf},
}

@book{lamport_specifying_2003-1,
	address = {Boston},
	title = {Specifying systems: the {TLA}+ language and tools for hardware and software engineers},
	isbn = {978-0-321-14306-8},
	shorttitle = {Specifying systems},
	language = {en},
	publisher = {Addison-Wesley},
	author = {Lamport, Leslie},
	year = {2003},
	keywords = {Computer systems, Logic, Symbolic and mathematical, Specifications, System design},
	file = {Lamport - 2003 - Specifying systems the TLA+ language and tools fo.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/EDCD5R6R/Lamport - 2003 - Specifying systems the TLA+ language and tools fo.pdf:application/pdf},
}

@book{stroustrup_c_2013,
	address = {Upper Saddle River, NJ},
	edition = {Fourth edition},
	title = {The {C}++ programming language},
	isbn = {978-0-321-56384-2},
	language = {en},
	publisher = {Addison-Wesley},
	author = {Stroustrup, Bjarne},
	year = {2013},
	keywords = {C++ (Computer program language)},
	file = {Stroustrup - 2013 - The C++ programming language.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/4L8YCT9S/Stroustrup - 2013 - The C++ programming language.pdf:application/pdf},
}

@article{ongaro_consensus_2014,
	title = {Consensus: {Bridging} {Theory} and {Practice}},
	language = {en},
	author = {Ongaro, Diego},
	year = {2014},
	pages = {258},
	file = {Ongaro - Consensus Bridging Theory and Practice.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/SDKMWZPP/Ongaro - Consensus Bridging Theory and Practice.pdf:application/pdf},
}

@inproceedings{bessani_state_2014,
	address = {Atlanta, GA, USA},
	title = {State {Machine} {Replication} for the {Masses} with {BFT}-{SMART}},
	isbn = {978-1-4799-2233-8},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6903593},
	doi = {10.1109/DSN.2014.43},
	abstract = {The last ﬁfteen years have seen an impressive amount of work on protocols for Byzantine fault-tolerant (BFT) state machine replication (SMR). However, there is still a need for practical and reliable software libraries implementing this technique. BFT-SMART is an open-source Java-based library implementing robust BFT state machine replication. Some of the key features of this library that distinguishes it from similar works (e.g., PBFT and UpRight) are improved reliability, modularity as a ﬁrst-class property, multicore-awareness, reconﬁguration support and a ﬂexible programming interface. When compared to other SMR libraries, BFT-SMART achieves better performance and is able to withstand a number of realworld faults that previous implementations cannot.},
	language = {en},
	urldate = {2020-06-04},
	booktitle = {2014 44th {Annual} {IEEE}/{IFIP} {International} {Conference} on {Dependable} {Systems} and {Networks}},
	publisher = {IEEE},
	author = {Bessani, Alysson and Sousa, Joao and Alchieri, Eduardo E.P.},
	month = jun,
	year = {2014},
	pages = {355--362},
	file = {Bessani et al. - 2014 - State Machine Replication for the Masses with BFT-.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TJV2IWIX/Bessani et al. - 2014 - State Machine Replication for the Masses with BFT-.pdf:application/pdf},
}

@article{bessani_efciency_2013,
	title = {On the {Efﬁciency} of {Durable} {State} {Machine} {Replication}},
	abstract = {State Machine Replication (SMR) is a fundamental technique for ensuring the dependability of critical services in modern internet-scale infrastructures. SMR alone does not protect from full crashes, and thus in practice it is employed together with secondary storage to ensure the durability of the data managed by these services. In this work we show that the classical durability enforcing mechanisms – logging, checkpointing, state transfer – can have a high impact on the performance of SMRbased services even if SSDs are used instead of disks. To alleviate this impact, we propose three techniques that can be used in a transparent manner, i.e., without modifying the SMR programming model or requiring extra resources: parallel logging, sequential checkpointing, and collaborative state transfer. We show the beneﬁts of these techniques experimentally by implementing them in an open-source replication library, and evaluating them in the context of a consistent key-value store and a coordination service.},
	language = {en},
	author = {Bessani, Alysson and Santos, Marcel and Felix, Joao and Neves, Nuno and Correia, Miguel},
	year = {2013},
	pages = {12},
	file = {Bessani et al. - On the Efﬁciency of Durable State Machine Replicat.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/TJ4KDG58/Bessani et al. - On the Efﬁciency of Durable State Machine Replicat.pdf:application/pdf},
}

@article{ongaro_search_2014,
	title = {In {Search} of an {Understandable} {Consensus} {Algorithm}},
	abstract = {Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efﬁcient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems. In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered. Results from a user study demonstrate that Raft is easier for students to learn than Paxos. Raft also includes a new mechanism for changing the cluster membership, which uses overlapping majorities to guarantee safety.},
	language = {en},
	author = {Ongaro, Diego and Ousterhout, John},
	year = {2014},
	pages = {18},
	file = {Ongaro et Ousterhout - In Search of an Understandable Consensus Algorithm.pdf:/home/pato/snap/zotero-snap/common/Zotero/storage/F3JAZFLC/Ongaro et Ousterhout - In Search of an Understandable Consensus Algorithm.pdf:application/pdf},
}

@article{engelhardt_causing_2007,
	title = {Causing {Communication} {Closure}: {Safe} {Program} {Composition} with {Reliable} {Non}-{FIFO} {Channels}},
	shorttitle = {Causing {Communication} {Closure}},
	url = {http://arxiv.org/abs/cs/0701064},
	abstract = {A semantic framework for analyzing safe composition of distributed programs is presented. Its applicability is illustrated by a study of program composition when communication is reliable but not necessarily FIFO{\textbackslash}@. In this model, special care must be taken to ensure that messages do not accidentally overtake one another in the composed program. We show that barriers do not exist in this model. Indeed, no program that sends or receives messages can automatically be composed with arbitrary programs without jeopardizing their intended behavior. Safety of composition becomes context-sensitive and new tools are needed for ensuring it. A notion of {\textbackslash}emph\{sealing\} is defined, where if a program \$P\$ is immediately followed by a program \$Q\$ that seals \$P\$ then \$P\$ will be communication-closed--it will execute as if it runs in isolation. The investigation of sealing in this model reveals a novel connection between Lamport causality and safe composition. A characterization of sealable programs is given, as well as efficient algorithms for testing if \$Q\$ seals \$P\$ and for constructing a seal for a significant class of programs. It is shown that every sealable program that is open to interference on \$O(n{\textasciicircum}2)\$ channels can be sealed using O(n) messages.},
	urldate = {2020-05-13},
	journal = {arXiv:cs/0701064},
	author = {Engelhardt, Kai and Moses, Yoram},
	month = jan,
	year = {2007},
	note = {arXiv: cs/0701064},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {arXiv Fulltext PDF:/home/pato/snap/zotero-snap/common/Zotero/storage/2JSMDJ2F/Engelhardt et Moses - 2007 - Causing Communication Closure Safe Program Compos.pdf:application/pdf;arXiv.org Snapshot:/home/pato/snap/zotero-snap/common/Zotero/storage/SXMCBY9M/0701064.html:text/html},
}
